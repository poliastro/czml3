# generated by datamodel-codegen:
#   filename:  czml_api.json
#   timestamp: 2021-03-28T13:15:34+00:00

from __future__ import annotations

from datetime import datetime
from typing import Any, List, Optional, Union

from pydantic import BaseModel, Extra, Field


class DeletableProperty(BaseModel):
    """
    The base schema for a property whose value may be deleted.
    """

    delete: Optional[bool] = Field(
        None,
        description='Whether the client should delete existing samples or interval data for this property. Data will be deleted for the containing interval, or if there is no containing interval, then all data. If true, all other properties in this property will be ignored.',
    )


class LabelStyleValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a label style.',
    )


class ReferenceValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a reference to another property.',
    )


class LabelStyleValue(BaseModel):
    __root__: str = Field(..., description='The style of a label.')


class ReferenceValue(BaseModel):
    __root__: str = Field(
        ...,
        description='Represents a reference to another property. References can be used to specify that two properties on different objects are in fact, the same property.',
    )


class InterpolatableProperty(BaseModel):
    """
    The base schema for a property whose value may be determined by interpolating over provided time-tagged samples.
    """

    epoch: Optional[datetime] = Field(
        None,
        description='The epoch to use for times specified as seconds since an epoch.',
    )
    interpolationAlgorithm: Optional[str] = Field(
        'LINEAR',
        description='The interpolation algorithm to use when interpolating. Valid values are "LINEAR", "LAGRANGE", and "HERMITE".',
    )
    interpolationDegree: Optional[float] = Field(
        1, description='The degree of interpolation to use when interpolating.'
    )
    forwardExtrapolationType: Optional[str] = Field(
        'NONE',
        description='The type of extrapolation to perform when a value is requested at a time after any available samples. Valid values are "NONE", "HOLD", and "EXTRAPOLATE".',
    )
    forwardExtrapolationDuration: Optional[float] = Field(
        0.0,
        description='The amount of time to extrapolate forward before the property becomes undefined. A value of 0 will extrapolate forever.',
    )
    backwardExtrapolationType: Optional[str] = Field(
        'NONE',
        description='The type of extrapolation to perform when a value is requested at a time before any available samples. Valid values are "NONE", "HOLD", and "EXTRAPOLATE".',
    )
    backwardExtrapolationDuration: Optional[float] = Field(
        0.0,
        description='The amount of time to extrapolate backward before the property becomes undefined. A value of 0 will extrapolate forever.',
    )


class IntegerValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as an integer.',
    )


class IntegerValue(BaseModel):
    __root__: Union[int, List[Any]] = Field(
        ...,
        description='An integer number. The value may be a single integer, or an array with one element, in which case the value is constant. If it is an array with two or more elements, they are time-tagged samples arranged as `[Time, Value, Time, Value, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
    )


class BooleanValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a boolean.',
    )


class BooleanValue(BaseModel):
    __root__: bool = Field(..., description='A boolean value.')


class DoubleValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a floating-point number.',
    )


class DoubleValue(BaseModel):
    __root__: Union[float, List[Any]] = Field(
        ...,
        description='A floating-point number. The value may be a single number, or an array with one element, in which case the value is constant. If it is an array with two or more elements, they are time-tagged samples arranged as `[Time, Value, Time, Value, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
    )


class HeightReferenceValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a height reference.',
    )


class HeightReferenceValue(BaseModel):
    __root__: str = Field(
        ...,
        description="The height reference of an object, which indicates if the object's position is relative to terrain or not.",
    )


class RgbaValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0-255.',
    )


class RgbafValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0.0-1.0.',
    )


class RgbaValue(BaseModel):
    """
    A color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0-255. If the array has four elements, the color is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, Red, Green, Blue, Alpha, Time, Red, Green, Blue, Alpha, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0-255. If the array has four elements, the color is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, Red, Green, Blue, Alpha, Time, Red, Green, Blue, Alpha, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Rgba',
    )


class RgbafValue(BaseModel):
    """
    A color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0.0-1.0. If the array has four elements, the color is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, Red, Green, Blue, Alpha, Time, Red, Green, Blue, Alpha, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is in the range 0.0-1.0. If the array has four elements, the color is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, Red, Green, Blue, Alpha, Time, Red, Green, Blue, Alpha, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Rgbaf',
    )


class UriValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a URI.',
    )


class UriValue(BaseModel):
    __root__: str = Field(..., description='A URI value.')


class Cartesian2ValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a two-dimensional Cartesian.',
    )


class Cartesian2Value(BaseModel):
    """
    A two-dimensional Cartesian value specified as `[X, Y]`. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, X, Y, Time, X, Y, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A two-dimensional Cartesian value specified as `[X, Y]`. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, X, Y, Time, X, Y, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Cartesian2',
    )


class LineCount(BaseModel):
    """
    The number of grid lines along each axis.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None, description='The number of grid lines along each axis.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The number of grid lines along each axis specified as a reference to another property.',
    )


class LineThickness(BaseModel):
    """
    The thickness of grid lines along each axis, in pixels.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None,
        description='The thickness specified as a two-dimensional Cartesian value `[X, Y]`, in pixels.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The thickness specified as a reference to another property.'
    )


class LineOffset(BaseModel):
    """
    The offset of grid lines along each axis, as a percentage from 0 to 1.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None,
        description='The offset of grid lines along each axis, specified as a percentage from 0 to 1.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The offset of grid lines along each axis specified as a reference to another property.',
    )


class StripeOrientationValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a stripe orientation.',
    )


class StripeOrientationValue(BaseModel):
    __root__: str = Field(
        ..., description='The orientation of stripes in the stripe material.'
    )


class Integer(BaseModel):
    """
    An integer number.
    """

    number: Optional[IntegerValue] = Field(None, description='The integer.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The integer specified as a reference to another property.'
    )


class ShadowModeValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a shadow mode.',
    )


class ShadowModeValue(BaseModel):
    __root__: str = Field(
        ...,
        description='Whether or not an object casts or receives shadows from each light source when shadows are enabled.',
    )


class DistanceDisplayConditionValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as two values `[NearDistance, FarDistance]`.',
    )


class DistanceDisplayConditionValue(BaseModel):
    """
    A value indicating the visibility of an object based on the distance to the camera, specified as two values `[NearDistance, FarDistance]`. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, NearDistance, FarDistance, Time, NearDistance, FarDistance, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A value indicating the visibility of an object based on the distance to the camera, specified as two values `[NearDistance, FarDistance]`. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, NearDistance, FarDistance, Time, NearDistance, FarDistance, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='DistanceDisplayCondition',
    )


class Cartesian3ValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a three-dimensional Cartesian.',
    )


class CartographicRadiansValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters.',
    )


class CartographicDegreesValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )


class Cartesian3VelocityValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a three-dimensional Cartesian and its derivative.',
    )


class Cartesian3Value(BaseModel):
    """
    A three-dimensional Cartesian value specified as `[X, Y, Z]`. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, Time, X, Y, Z, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A three-dimensional Cartesian value specified as `[X, Y, Z]`. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, Time, X, Y, Z, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Cartesian3',
    )


class CartographicRadiansValue(BaseModel):
    """
    A geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Longitude, Latitude, Height, Time, Longitude, Latitude, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Longitude, Latitude, Height, Time, Longitude, Latitude, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='CartographicRadians',
    )


class CartographicDegreesValue(BaseModel):
    """
    A geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Longitude, Latitude, Height, Time, Longitude, Latitude, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A geodetic, WGS84 position specified as `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Longitude, Latitude, Height, Time, Longitude, Latitude, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='CartographicDegrees',
    )


class Cartesian3VelocityValue(BaseModel):
    """
    A three-dimensional Cartesian value and its derivative specified as `[X, Y, Z, dX, dY, dZ]`. If the array has six elements, the value is constant. If it has seven or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, dX, dY, dZ, Time, X, Y, Z, dX, dY, dZ, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A three-dimensional Cartesian value and its derivative specified as `[X, Y, Z, dX, dY, dZ]`. If the array has six elements, the value is constant. If it has seven or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, dX, dY, dZ, Time, X, Y, Z, dX, dY, dZ, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Cartesian3Velocity',
    )


class Translation(BaseModel):
    """
    A translational offset which can optionally vary over time.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The translation specified as a three-dimensional Cartesian value `[X, Y, Z]`, in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The translation specified as a reference to another property.',
    )


class UnitQuaternionValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a 4-dimensional unit magnitude quaternion, specified as `[X, Y, Z, W]`.',
    )


class UnitQuaternionValue(BaseModel):
    """
    A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space, specified as `[X, Y, Z, W]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, W, Time, X, Y, Z, W, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space, specified as `[X, Y, Z, W]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, W, Time, X, Y, Z, W, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='UnitQuaternion',
    )


class Scale(BaseModel):
    """
    A scaling factor which can optionally vary over time.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The scale specified as a three-dimensional Cartesian value `[X, Y, Z]`.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The scale specified as a reference to another property.'
    )


class NearFarScalarValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a near-far scalar value specified as four values `[NearDistance, NearValue, FarDistance, FarValue]`.',
    )


class NearFarScalarValue(BaseModel):
    """
    A near-far scalar value specified as four values `[NearDistance, NearValue, FarDistance, FarValue]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, NearDistance, NearValue, FarDistance, FarValue, Time, NearDistance, NearValue, FarDistance, FarValue, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A near-far scalar value specified as four values `[NearDistance, NearValue, FarDistance, FarValue]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, NearDistance, NearValue, FarDistance, FarValue, Time, NearDistance, NearValue, FarDistance, FarValue, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='NearFarScalar',
    )


class ColorBlendModeValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a type of arc.',
    )


class ColorBlendModeValue(BaseModel):
    __root__: str = Field(
        ...,
        description="The mode of blending between a target color and an entity's source color.",
    )


class NodeTransformations(BaseModel):
    """
    A mapping of node names to node transformations.
    """

    pass

    class Config:
        extra = Extra.allow


class Articulations(BaseModel):
    """
    A mapping of keys to articulation values, where the keys are the name of the articulation, a single space, and the name of the stage.
    """

    pass

    class Config:
        extra = Extra.allow


class Articulation(BaseModel):
    """
    An articulation value.
    """

    number: Optional[DoubleValue] = Field(None, description='The articulation value.')
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The articulation value specified as a reference to another property.',
    )


class ClassificationTypeValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a classification type.',
    )


class ClassificationTypeValue(BaseModel):
    __root__: str = Field(
        ..., description='Whether a classification affects terrain, 3D Tiles, or both.'
    )


class BoundingRectangleValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a bounding rectangle.',
    )


class UnitCartesian3ValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a three-dimensional unit magnitude Cartesian.',
    )


class SphericalValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a spherical.',
    )


class UnitSphericalValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a unit spherical.',
    )


class CornerTypeValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a type of corner.',
    )


class HorizontalOriginValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a horizontal origin.',
    )


class StringValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a string.',
    )


class CartographicRectangleRadiansValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in radians.',
    )


class CartographicRectangleDegreesValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in degrees.',
    )


class VerticalOriginValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a vertical origin.',
    )


class BoundingRectangleValue(BaseModel):
    """
    A near-far scalar value specified as four values `[X, Y, Width, Height]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, X, Y, Width, Height, Time, X, Y, Width, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A near-far scalar value specified as four values `[X, Y, Width, Height]`. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, X, Y, Width, Height, Time, X, Y, Width, Height, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='BoundingRectangle',
    )


class UnitCartesian3Value(BaseModel):
    """
    A three-dimensional unit magnitude Cartesian value specified as `[X, Y, Z]`. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, Time, X, Y, Z, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A three-dimensional unit magnitude Cartesian value specified as `[X, Y, Z]`. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, Time, X, Y, Z, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='UnitCartesian3',
    )


class SphericalValue(BaseModel):
    """
    A spherical value `[Clock, Cone, Magnitude]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Clock, Cone, Magnitude, Time, Clock, Cone, Magnitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A spherical value `[Clock, Cone, Magnitude]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis. If the array has three elements, the value is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, Clock, Cone, Magnitude, Time, Clock, Cone, Magnitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='Spherical',
    )


class UnitSphericalValue(BaseModel):
    """
    A unit spherical value specified as `[Clock, Cone]` angles. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, Clock, Cone, Time, Clock, Cone, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A unit spherical value specified as `[Clock, Cone]` angles. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis. If the array has two elements, the value is constant. If it has three or more elements, they are time-tagged samples arranged as `[Time, Clock, Cone, Time, Clock, Cone, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='UnitSpherical',
    )


class CornerTypeValue(BaseModel):
    __root__: str = Field(..., description='The style of a corner.')


class HorizontalOriginValue(BaseModel):
    __root__: str = Field(
        ...,
        description="The horizontal location of an origin relative to an object's position.",
    )


class StringValue(BaseModel):
    __root__: str = Field(..., description='A string value.')


class CartographicRectangleRadiansValue(BaseModel):
    """
    A two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in radians. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in radians. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='CartographicRectangleRadians',
    )


class CartographicRectangleDegreesValue(BaseModel):
    """
    A two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in degrees. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.
    """

    __root__: List = Field(
        ...,
        description='A two-dimensional region specified as `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in degrees. If the array has four elements, the value is constant. If it has five or more elements, they are time-tagged samples arranged as `[Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, Time, WestLongitude, SouthLatitude, EastLongitude, NorthLatitude, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
        title='CartographicRectangleDegrees',
    )


class VerticalOriginValue(BaseModel):
    __root__: str = Field(
        ...,
        description="The vertical location of an origin relative to an object's position.",
    )


class StripeOrientation(BaseModel):
    """
    The orientation of stripes in a stripe material.
    """

    stripeOrientation: Optional[StripeOrientationValue] = Field(
        None, description='The orientation of stripes in the stripe material.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The orientation of stripes specified as a reference to another property.',
    )


class HeightReference(BaseModel):
    """
    The height reference of an object, which indicates if the object's position is relative to terrain or not.
    """

    heightReference: Optional[HeightReferenceValue] = Field(
        None, description='The height reference.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The height reference specified as a reference to another property.',
    )


class RectangleCoordinates(BaseModel):
    """
    A set of coordinates describing a cartographic rectangle on the surface of the ellipsoid.
    """

    wsen: Optional[CartographicRectangleRadiansValue] = Field(
        None,
        description='The set of coordinates specified as Cartographic values `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in radians.',
    )
    wsenDegrees: Optional[CartographicRectangleDegreesValue] = Field(
        None,
        description='The set of coordinates specified as Cartographic values `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in degrees.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The set of coordinates specified as a reference to another property.',
    )


class ClassificationType(BaseModel):
    """
    Whether a classification affects terrain, 3D Tiles, or both.
    """

    classificationType: Optional[ClassificationTypeValue] = Field(
        None,
        description='The classification type, which indicates whether a classification affects terrain, 3D Tiles, or both.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The classification type specified as a reference to another property.',
    )


class BoxDimensions(BaseModel):
    """
    The width, depth, and height of a box.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The dimensions specified as a three-dimensional Cartesian value `[X, Y, Z]`, with X representing width, Y representing depth, and Z representing height, in world coordinates in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The dimensions specified as a reference to another property.'
    )


class NearFarScalar(BaseModel):
    """
    A numeric value which will be linearly interpolated between two values based on an object's distance from the camera, in eye coordinates. The computed value will interpolate between the near value and the far value while the camera distance falls between the near distance and the far distance, and will be clamped to the near or far value while the distance is less than the near distance or greater than the far distance, respectively.
    """

    nearFarScalar: Optional[NearFarScalarValue] = Field(
        None,
        description='The value specified as four values `[NearDistance, NearValue, FarDistance, FarValue]`, with distances in eye coordinates in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The value specified as a reference to another property.'
    )


class Double(BaseModel):
    """
    A floating-point number.
    """

    number: Optional[DoubleValue] = Field(None, description='The number.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The number specified as a reference to another property.'
    )


class Cartesian3ListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of three-dimensional Cartesian values.',
    )


class CartographicRadiansListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
    )


class CartographicDegreesListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )


class ReferenceListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of references to other properties.',
    )


class Cartesian3ListValue(BaseModel):
    """
    A list of three-dimensional Cartesian values specified as `[X, Y, Z, X, Y, Z, ...]`.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of three-dimensional Cartesian values specified as `[X, Y, Z, X, Y, Z, ...]`.',
        title='Cartesian3List',
    )


class CartographicRadiansListValue(BaseModel):
    """
    A list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
        title='CartographicRadiansList',
    )


class CartographicDegreesListValue(BaseModel):
    """
    A list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
        title='CartographicDegreesList',
    )


class ReferenceListValue(BaseModel):
    """
    A list of references to other properties.
    """

    __root__: List[str] = Field(
        ...,
        description='A list of references to other properties.',
        title='ReferenceList',
    )


class Cartesian3ListOfListsValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of lists of three-dimensional Cartesian values.',
    )


class CartographicRadiansListOfListsValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
    )


class CartographicDegreesListOfListsValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )


class ReferenceListOfListsValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of lists of references to other properties.',
    )


class Cartesian3ListOfListsValue(BaseModel):
    """
    A list of lists of three-dimensional Cartesian values specified as `[X, Y, Z, X, Y, Z, ...]`.
    """

    __root__: List[List] = Field(
        ...,
        description='A list of lists of three-dimensional Cartesian values specified as `[X, Y, Z, X, Y, Z, ...]`.',
        title='Cartesian3ListOfLists',
    )


class CartographicRadiansListOfListsValue(BaseModel):
    """
    A list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.
    """

    __root__: List[List] = Field(
        ...,
        description='A list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
        title='CartographicRadiansListOfLists',
    )


class CartographicDegreesListOfListsValue(BaseModel):
    """
    A list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.
    """

    __root__: List[List] = Field(
        ...,
        description='A list of lists of geodetic, WGS84 positions specified as `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
        title='CartographicDegreesListOfLists',
    )


class ReferenceListOfListsValue(BaseModel):
    """
    A list of lists of references to other properties.
    """

    __root__: List[List] = Field(
        ...,
        description='A list of lists of references to other properties.',
        title='ReferenceListOfLists',
    )


class ArcTypeValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a type of arc.',
    )


class ArcTypeValue(BaseModel):
    __root__: str = Field(..., description='The type of an arc.')


class BoundingRectangle(BaseModel):
    """
    A bounding rectangle specified by a corner, width and height.
    """

    boundingRectangle: Optional[BoundingRectangleValue] = Field(
        None, description='The bounding rectangle specified as `[X, Y, Width, Height]`.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The bounding rectangle specified as a reference to another property.',
    )


class CornerType(BaseModel):
    """
    The style of a corner.
    """

    cornerType: Optional[CornerTypeValue] = Field(None, description='The corner style.')
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The corner style specified as a reference to another property.',
    )


class BoxDimensionsModel(BoxDimensions):
    """
    The width, depth, and height of a box.
    """

    pass


class TimeValue(BaseModel):
    __root__: str = Field(..., description='A time, specified in ISO8601 format.')


class ClockRangeValue(BaseModel):
    __root__: str = Field(
        ...,
        description='The behavior of a clock when its current time reaches its start or end time.',
    )


class ClockStepValue(BaseModel):
    __root__: str = Field(..., description='Defines how a clock advances each tick.')


class Cartesian2ListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of two-dimensional Cartesian values.',
    )


class Cartesian2ListValue(BaseModel):
    """
    A list of two-dimensional Cartesian values specified as `[X, Y, X, Y, ...]`.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of two-dimensional Cartesian values specified as `[X, Y, X, Y, ...]`.',
        title='Cartesian2List',
    )


class EllipsoidRadii(BaseModel):
    """
    The radii of an ellipsoid.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The radii specified as a three-dimensional Cartesian value `[X, Y, Z]`, in world coordinates in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The radii specified as a reference to another property.'
    )


class String(BaseModel):
    """
    A string value. The string can optionally vary with time.
    """

    string: Optional[StringValue] = Field(None, description='The string value.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The string specified as a reference to another property.'
    )


class FontValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a CSS font.',
    )


class FontValue(BaseModel):
    __root__: str = Field(
        ...,
        description='A font, specified using the same syntax as the CSS "font" property.',
    )


class LabelStyle(BaseModel):
    """
    The style of a label.
    """

    labelStyle: Optional[LabelStyleValue] = Field(None, description='The label style.')
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The label style specified as a reference to another property.',
    )


class BackgroundPadding(BaseModel):
    """
    The amount of horizontal and vertical padding, in pixels, between a label's text and its background.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None,
        description='The background padding specified as a two-dimensional Cartesian value `[X, Y]`, in pixels, where X is the horizontal padding, and Y is the vertical padding.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The background padding specified as a reference to another property.',
    )


class PixelOffset(BaseModel):
    """
    A pixel offset in viewport coordinates. A pixel offset is the number of pixels up and to the right to place an element relative to an origin.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None,
        description='The pixel offset specified as a two-dimensional Cartesian value `[X, Y]`, in viewport coordinates in pixels, where X is pixels to the right and Y is pixels up.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The pixel offset specified as a reference to another property.',
    )


class EyeOffset(BaseModel):
    """
    An offset in eye coordinates which can optionally vary over time. Eye coordinates are a left-handed coordinate system where the X-axis points toward the viewer's right, the Y-axis poitns up, and the Z-axis points into the screen.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The eye offset specified as a three-dimensional Cartesian value `[X, Y, Z]`, in eye coordinates in meters. If the array has three elements, the eye offset is constant. If it has four or more elements, they are time-tagged samples arranged as `[Time, X, Y, Z, Time, X, Y, Z, ...]`, where Time is an ISO 8601 date and time string or seconds since epoch.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The eye offset specified as a reference to another property.'
    )


class HorizontalOrigin(BaseModel):
    """
    The horizontal origin of an element, which can optionally vary over time. It controls whether the element is left-, center-, or right-aligned with the `position`.
    """

    horizontalOrigin: Optional[HorizontalOriginValue] = Field(
        None, description='The horizontal origin.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The horizontal origin specified as a reference to another property.',
    )


class VerticalOrigin(BaseModel):
    """
    The vertical origin of an element, which can optionally vary over time. It controls whether the element is bottom-, center-, or top-aligned with the `position`.
    """

    verticalOrigin: Optional[VerticalOriginValue] = Field(
        None, description='The vertical origin.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The vertical origin specified as a reference to another property.',
    )


class DoubleListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of floating-point numbers.',
    )


class DoubleListValue(BaseModel):
    """
    A list of values specified as an array of numbers.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of values specified as an array of numbers.',
        title='DoubleList',
    )


class InterpolatablePropertyModel(InterpolatableProperty):
    """
    The base schema for a property whose value may be determined by interpolating over provided time-tagged samples.
    """

    pass


class ScaleModel(Scale):
    """
    A scaling factor which can optionally vary over time.
    """

    pass


class Uri(BaseModel):
    """
    A URI value. The URI can optionally vary with time.
    """

    uri: Optional[UriValue] = Field(None, description='The URI value.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The URI specified as a reference to another property.'
    )


class PositionList(BaseModel):
    """
    A list of positions.
    """

    referenceFrame: Optional[str] = Field(
        'FIXED',
        description='The reference frame in which cartesian positions are specified. Possible values are "FIXED" and "INERTIAL".',
    )
    cartesian: Optional[Cartesian3ListValue] = Field(
        None,
        description='The list of positions specified as three-dimensional Cartesian values, `[X, Y, Z, X, Y, Z, ...]`, in meters relative to the `referenceFrame`.',
    )
    cartographicRadians: Optional[CartographicRadiansListValue] = Field(
        None,
        description='The list of positions specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
    )
    cartographicDegrees: Optional[CartographicDegreesListValue] = Field(
        None,
        description='The list of positions specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )
    references: Optional[ReferenceListValue] = Field(
        None,
        description='The list of positions specified as references. Each reference is to a property that defines a single position, which may change with time.',
    )


class LineThicknessModel(LineThickness):
    """
    The thickness of grid lines along each axis, in pixels.
    """

    pass


class CustomProperties(BaseModel):
    """
    A set of custom properties.
    """

    pass

    class Config:
        extra = Extra.allow


class CustomProperty(BaseModel):
    """
    A custom property.
    """

    boolean: Optional[BooleanValue] = Field(
        None, description='The property specified as a boolean value.'
    )
    boundingRectangle: Optional[BoundingRectangleValue] = Field(
        None, description='The property specified as `[X, Y, Width, Height]`.'
    )
    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The property specified as a three-dimensional Cartesian value `[X, Y, Z]`.',
    )
    cartographicRadians: Optional[CartographicRadiansValue] = Field(
        None,
        description='The property specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters.',
    )
    cartographicDegrees: Optional[CartographicDegreesValue] = Field(
        None,
        description='The property specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )
    cartesian2: Optional[Cartesian2Value] = Field(
        None,
        description='The property specified as a two-dimensional Cartesian value `[X, Y]`.',
    )
    unitCartesian: Optional[UnitCartesian3Value] = Field(
        None,
        description='The property specified as a three-dimensional unit magnitude Cartesian value `[X, Y, Z]`.',
    )
    spherical: Optional[SphericalValue] = Field(
        None,
        description='The property specified as a spherical value `[Clock, Cone, Magnitude]`. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    unitSpherical: Optional[UnitSphericalValue] = Field(
        None,
        description='The property specified as a unit spherical value `[Clock, Cone]`. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    rgba: Optional[RgbaValue] = Field(
        None,
        description='The property specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is an integer in the range 0-255.',
    )
    rgbaf: Optional[RgbafValue] = Field(
        None,
        description='The property specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is a double in the range 0.0-1.0.',
    )
    colorBlendMode: Optional[ColorBlendModeValue] = Field(
        None, description='The property specified as a color blend mode.'
    )
    cornerType: Optional[CornerTypeValue] = Field(
        None, description='The property specified as a corner style.'
    )
    heightReference: Optional[HeightReferenceValue] = Field(
        None, description='The property specified as a height reference.'
    )
    horizontalOrigin: Optional[HorizontalOriginValue] = Field(
        None, description='The property specified as a horizontal origin.'
    )
    labelStyle: Optional[LabelStyleValue] = Field(
        None, description='The property specified as a label style.'
    )
    number: Optional[DoubleValue] = Field(
        None, description='The property specified as a number.'
    )
    nearFarScalar: Optional[NearFarScalarValue] = Field(
        None,
        description='The property specified as four values `[NearDistance, NearValue, FarDistance, FarValue]`.',
    )
    unitQuaternion: Optional[UnitQuaternionValue] = Field(
        None,
        description='The property specified as a 4-dimensional unit magnitude quaternion, specified as `[X, Y, Z, W]`.',
    )
    shadowMode: Optional[ShadowModeValue] = Field(
        None, description='The property specified as a shadow mode.'
    )
    string: Optional[StringValue] = Field(
        None, description='The property specified as a string.'
    )
    stripeOrientation: Optional[StripeOrientationValue] = Field(
        None,
        description='The property specified as an orientation of stripes in the stripe material.',
    )
    wsen: Optional[CartographicRectangleRadiansValue] = Field(
        None,
        description='The property specified as a Cartographic rectangle `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in radians.',
    )
    wsenDegrees: Optional[CartographicRectangleDegreesValue] = Field(
        None,
        description='The property specified as a Cartographic rectangle `[WestLongitude, SouthLatitude, EastLongitude, NorthLatitude]`, with values in degrees.',
    )
    uri: Optional[UriValue] = Field(
        None, description='The property specified as a URI.'
    )
    verticalOrigin: Optional[VerticalOriginValue] = Field(
        None, description='The property specified as a vertical origin.'
    )


class VelocityReferenceValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class VelocityReferenceValue(BaseModel):
    __root__: str = Field(
        ...,
        description='Represents the normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class Font(BaseModel):
    """
    A font used to draw text. Fonts are specified using the same syntax as the CSS "font" property.
    """

    font: Optional[FontValue] = Field(
        None,
        description='The font, specified using the same syntax as the CSS "font" property.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The font specified as a reference to another property.'
    )


class ShadowMode(BaseModel):
    """
    Whether or not an object casts or receives shadows from each light source when shadows are enabled.
    """

    shadowMode: Optional[ShadowModeValue] = Field(None, description='The shadow mode.')
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The shadow mode specified as a reference to another property.',
    )


class RectangleCoordinatesModel(RectangleCoordinates):
    """
    A set of coordinates describing a cartographic rectangle on the surface of the ellipsoid.
    """

    pass


class DistanceDisplayCondition(BaseModel):
    """
    Indicates the visibility of an object based on the distance to the camera.
    """

    distanceDisplayCondition: Optional[DistanceDisplayConditionValue] = Field(
        None,
        description='The value specified as two values `[NearDistance, FarDistance]`, with distances in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The value specified as a reference to another property.'
    )


class ArcType(BaseModel):
    """
    The type of an arc.
    """

    arcType: Optional[ArcTypeValue] = Field(None, description='The arc type.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The arc type specified as a reference to another property.'
    )


class PositionListOfLists(BaseModel):
    """
    A list of lists of positions.
    """

    cartesian: Optional[Cartesian3ListOfListsValue] = Field(
        None,
        description='The list of lists of positions specified as three-dimensional Cartesian values, `[X, Y, Z, X, Y, Z, ...]`, in meters relative to the `referenceFrame`.',
    )
    cartographicRadians: Optional[CartographicRadiansListOfListsValue] = Field(
        None,
        description='The list of lists of positions specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in radians and Height is in meters.',
    )
    cartographicDegrees: Optional[CartographicDegreesListOfListsValue] = Field(
        None,
        description='The list of lists of positions specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height, Longitude, Latitude, Height, ...]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )
    references: Optional[ReferenceListOfListsValue] = Field(
        None,
        description='The list of lists of positions specified as references. Each reference is to a property that defines a single position, which may change with time.',
    )


class Package(BaseModel):
    __root__: Any = Field(..., description='CZML JSON Schema')


class Repeat(BaseModel):
    """
    The number of times an image repeats along each axis.
    """

    cartesian2: Optional[Cartesian2Value] = Field(
        None, description='The number of times the image repeats along each axis.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The number of times the image repeats specified as a reference to another property.',
    )


class ViewFrom(BaseModel):
    """
    A suggested initial camera position offset when tracking this object, specified as a Cartesian position. Typically defined in the East (x), North (y), Up (z) reference frame relative to the object's position, but may use another frame depending on the object's velocity.
    """

    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The offset specified as a three-dimensional Cartesian value `[X, Y, Z]`.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The offset specified as a reference to another property.'
    )


class Color(BaseModel):
    """
    A color. The color can optionally vary over time.
    """

    rgba: Optional[RgbaValue] = Field(
        None,
        description='The color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is an integer in the range 0-255.',
    )
    rgbaf: Optional[RgbafValue] = Field(
        None,
        description='The color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is a double in the range 0.0-1.0.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The color specified as a reference to another property.'
    )


class Clock(BaseModel):
    """
    Initial settings for a simulated clock when a document is loaded. The start and stop time are configured using the interval property.
    """

    currentTime: Optional[TimeValue] = Field(
        None, description='The current time, specified in ISO8601 format.'
    )
    multiplier: Optional[float] = Field(
        1.0,
        description='The multiplier. When `step` is set to `TICK_DEPENDENT`, this is the number of seconds to advance each tick. When `step` is set to `SYSTEM_CLOCK_DEPENDENT`, this is multiplied by the elapsed system time between ticks. This value is ignored in `SYSTEM_CLOCK` mode.',
    )
    range: Optional[ClockRangeValue] = Field(
        'LOOP_STOP',
        description='The behavior when the current time reaches its start or end times.',
    )
    step: Optional[ClockStepValue] = Field(
        'SYSTEM_CLOCK_MULTIPLIER',
        description='How the current time advances each tick.',
    )


class TimeIntervalCollectionValue(BaseModel):
    __root__: Union[List[Any], str] = Field(
        ...,
        description='A collection of time intervals, specified in ISO8601 interval format.',
    )


class Position(BaseModel):
    """
    Defines a position. The position can optionally vary over time.
    """

    referenceFrame: Optional[str] = Field(
        'FIXED',
        description='The reference frame in which cartesian positions are specified. Possible values are "FIXED" and "INERTIAL".',
    )
    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The position specified as a three-dimensional Cartesian value, `[X, Y, Z]`, in meters relative to the `referenceFrame`.',
    )
    cartographicRadians: Optional[CartographicRadiansValue] = Field(
        None,
        description='The position specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters.',
    )
    cartographicDegrees: Optional[CartographicDegreesValue] = Field(
        None,
        description='The position specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )
    cartesianVelocity: Optional[Cartesian3VelocityValue] = Field(
        None,
        description='The position and velocity specified as a three-dimensional Cartesian value and its derivative, `[X, Y, Z, dX, dY, dZ]`, in meters relative to the `referenceFrame`.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The position specified as a reference to another property.'
    )


class Orientation(BaseModel):
    """
    Defines an orientation. An orientation is a rotation that takes a vector expressed in the "body" axes of the object and transforms it to the Earth fixed axes.
    """

    unitQuaternion: Optional[UnitQuaternionValue] = Field(
        None,
        description='The orientation specified as a 4-dimensional unit magnitude quaternion, specified as `[X, Y, Z, W]`.',
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The orientation specified as a reference to another property.',
    )
    velocityReference: Optional[VelocityReferenceValue] = Field(
        None,
        description='The orientation specified as the normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class ViewFromModel(ViewFrom):
    """
    A suggested initial camera position offset when tracking this object, specified as a Cartesian position. Typically defined in the East (x), North (y), Up (z) reference frame relative to the object's position, but may use another frame depending on the object's velocity.
    """

    pass


class AlignedAxis(BaseModel):
    """
    An aligned axis represented by a unit vector which can optionally vary over time.
    """

    unitCartesian: Optional[UnitCartesian3Value] = Field(
        None,
        description='The axis specified as a three-dimensional unit magnitude Cartesian value `[X, Y, Z]`, in world coordinates.',
    )
    unitSpherical: Optional[UnitSphericalValue] = Field(
        None,
        description='The axis specified as a unit spherical value `[Clock, Cone]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The axis specified as a reference to another property.'
    )
    velocityReference: Optional[VelocityReferenceValue] = Field(
        None,
        description='The axis specified as the normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class BoundingRectangleModel(BoundingRectangle):
    """
    A bounding rectangle specified by a corner, width and height.
    """

    pass


class DoubleList(BaseModel):
    """
    A list of floating-point numbers.
    """

    array: Optional[DoubleListValue] = Field(
        None, description='The list of values specified as an array of numbers.'
    )
    references: Optional[ReferenceListValue] = Field(
        None,
        description='The list of values specified as references. Each reference is to a property that defines a single value, which may change with time.',
    )


class Boolean(BaseModel):
    """
    A boolean value.
    """

    boolean: Optional[BooleanValue] = Field(None, description='The boolean value.')
    reference: Optional[ReferenceValue] = Field(
        None, description='The boolean specified as a reference to another property.'
    )


class ColorModel(Color):
    """
    A color. The color can optionally vary over time.
    """

    pass


class SensorVolumePortionToDisplayValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a part of a sensor that should be displayed.',
    )


class SensorVolumePortionToDisplayValue(BaseModel):
    __root__: str = Field(..., description='What part of a sensor should be displayed.')


class IntegerModel(Integer):
    """
    An integer number.
    """

    pass


class SphericalListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of spherical values.',
    )


class UnitSphericalListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of unit spherical values.',
    )


class UnitCartesian3ListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of three-dimensional unit magnitude Cartesian values.',
    )


class SphericalListValue(BaseModel):
    """
    A list of spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
        title='SphericalList',
    )


class UnitSphericalListValue(BaseModel):
    """
    A list of unit spherical values specified as `[Clock, Cone, Clock, Cone, ...]` angles.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of unit spherical values specified as `[Clock, Cone, Clock, Cone, ...]` angles.',
        title='UnitSphericalList',
    )


class UnitCartesian3ListValue(BaseModel):
    """
    A list of three-dimensional unit magnitude Cartesian values, specified as `[X, Y, Z, X, Y, Z, ...]`.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of three-dimensional unit magnitude Cartesian values, specified as `[X, Y, Z, X, Y, Z, ...]`.',
        title='UnitCartesian3List',
    )


class Direction(BaseModel):
    """
    A unit vector, in world coordinates, that defines a direction.
    """

    spherical: Optional[SphericalValue] = Field(
        None,
        description='The direction specified as a spherical value `[Clock, Cone, Magnitude]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    unitSpherical: Optional[UnitSphericalValue] = Field(
        None,
        description='The direction specified as a unit spherical value `[Clock, Cone]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    cartesian: Optional[Cartesian3Value] = Field(
        None,
        description='The direction specified as a three-dimensional Cartesian value `[X, Y, Z]`, in world coordinates in meters.',
    )
    unitCartesian: Optional[UnitCartesian3Value] = Field(
        None,
        description='The direction specified as a three-dimensional unit magnitude Cartesian value `[X, Y, Z]`, in world coordinates in meters.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The direction specified as a reference to another property.'
    )


class DirectionList(BaseModel):
    """
    A list of directions.
    """

    spherical: Optional[SphericalListValue] = Field(
        None,
        description='The list of directions specified as spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    unitSpherical: Optional[UnitSphericalListValue] = Field(
        None,
        description='The list of directions specified as unit spherical values `[Clock, Cone, Clock, Cone, ...]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    cartesian: Optional[Cartesian3ListValue] = Field(
        None,
        description='The list of directions specified as three-dimensional Cartesian values `[X, Y, Z, X, Y, Z, ...]`, in world coordinates in meters.',
    )
    unitCartesian: Optional[UnitCartesian3ListValue] = Field(
        None,
        description='The list of directions specified as three-dimensional unit magnitude Cartesian values, `[X, Y, Z, X, Y, Z, ...]`, in world coordinates in meters.',
    )


class ColorBlendMode(BaseModel):
    """
    The mode of blending between a target color and an entity's source color.
    """

    colorBlendMode: Optional[ColorBlendModeValue] = Field(
        None, description='The color blend mode.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The color blend mode specified as a reference to another property.',
    )


class Shape(BaseModel):
    """
    A list of two-dimensional positions defining a shape.
    """

    cartesian2: Optional[Cartesian2ListValue] = Field(
        None,
        description='The list of positions specified as two-dimensional Cartesian values `[X, Y, X, Y, ...]`.',
    )


class DirectionModel(Direction):
    """
    A unit vector, in world coordinates, that defines a direction.
    """

    pass


class Rotation(BaseModel):
    """
    Defines a rotation that transforms a vector expressed in one axes and transforms it to another.
    """

    unitQuaternion: Optional[UnitQuaternionValue] = Field(
        None,
        description='The rotation specified as a 4-dimensional unit magnitude quaternion, specified as `[X, Y, Z, W]`.',
    )
    reference: Optional[ReferenceValue] = Field(
        None, description='The rotation specified as a reference to another property.'
    )


class LabelStyleModel(LabelStyle):
    """
    The style of a label.
    """

    pass


class BooleanModel(Boolean):
    """
    A boolean value.
    """

    pass


class HeightReferenceModel(HeightReference):
    """
    The height reference of an object, which indicates if the object's position is relative to terrain or not.
    """

    pass


class UriModel(Uri):
    """
    A URI value. The URI can optionally vary with time.
    """

    pass


class RepeatModel(Repeat):
    """
    The number of times an image repeats along each axis.
    """

    pass


class GridMaterial(BaseModel):
    """
    A material that fills the surface with a two-dimensional grid.
    """

    color: Optional[Color] = Field('white', description='The color of the surface.')
    cellAlpha: Optional[Double] = Field(
        0.1,
        description='The alpha value for the space between grid lines. This will be combined with the color alpha.',
    )
    lineCount: Optional[LineCount] = Field(
        '[8, 8]', description='The number of grid lines along each axis.'
    )
    lineThickness: Optional[LineThickness] = Field(
        '[1.0, 1.0]',
        description='The thickness of grid lines along each axis, in pixels.',
    )
    lineOffset: Optional[LineOffset] = Field(
        '[0.0, 0.0]',
        description='The offset of grid lines along each axis, as a percentage from 0 to 1.',
    )


class CheckerboardMaterial(BaseModel):
    """
    A material that fills the surface with a checkerboard pattern.
    """

    evenColor: Optional[Color] = Field('white', description='The even color.')
    oddColor: Optional[Color] = Field('black', description='The odd color.')
    repeat: Optional[RepeatModel] = Field(
        '[2, 2]', description='The number of times the tiles repeat along each axis.'
    )


class ShadowModeModel(ShadowMode):
    """
    Whether or not an object casts or receives shadows from each light source when shadows are enabled.
    """

    pass


class PolylineOutlineMaterial(BaseModel):
    """
    A material that fills the surface of a line with an outlined color.
    """

    color: Optional[Color] = Field('white', description='The color of the surface.')
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the surface outline.'
    )
    outlineWidth: Optional[Double] = Field(1.0, description='The width of the outline.')


class PolylineArrowMaterial(BaseModel):
    """
    A material that fills the surface of a line with an arrow.
    """

    color: Optional[Color] = Field('white', description='The color of the surface.')


class PolylineDashMaterial(BaseModel):
    """
    A material that fills the surface of a line with a pattern of dashes.
    """

    color: Optional[Color] = Field(
        'white', description='The color of the dashes on the line.'
    )
    gapColor: Optional[Color] = Field(
        'transparent', description='The color of the gaps between dashes on the line.'
    )
    dashLength: Optional[Double] = Field(
        16.0,
        description='The length in screen-space pixels of a single dash and gap pattern.',
    )
    dashPattern: Optional[Integer] = Field(
        255,
        description='A 16-bit bitfield representing which portions along a single dashLength are the dash (1) and which are the gap (0). The default value, 255 (0000000011111111), indicates 50% gap followed by 50% dash.',
    )


class PolylineGlowMaterial(BaseModel):
    """
    A material that fills the surface of a line with a glowing color.
    """

    color: Optional[Color] = Field('white', description='The color of the surface.')
    glowPower: Optional[Double] = Field(0.25, description='The strength of the glow.')
    taperPower: Optional[Double] = Field(
        1.0,
        description='The strength of the tapering effect.  1.0 and higher means no tapering.',
    )


class PositionModel(Position):
    """
    Defines a position. The position can optionally vary over time.
    """

    pass


class RotationModel(Rotation):
    """
    Defines a rotation that transforms a vector expressed in one axes and transforms it to another.
    """

    pass


class ColorBlendModeModel(ColorBlendMode):
    """
    The mode of blending between a target color and an entity's source color.
    """

    pass


class NodeTransformation(BaseModel):
    """
    A set of transformations to apply to a particular node in a 3D model.
    """

    translation: Optional[Translation] = Field(
        '[0.0, 0.0, 0.0]', description='The translation to apply to the model node.'
    )
    rotation: Optional[RotationModel] = Field(
        '[0.0, 0.0, 0.0, 1.0]', description='The rotation to apply to the model node.'
    )
    scale: Optional[Scale] = Field(
        '[1.0, 1.0, 1.0]', description='The scaling to apply to the model node.'
    )


class CustomPropertyModel(CustomProperty):
    """
    A custom property.
    """

    pass


class ImageMaterial(BaseModel):
    """
    A material that fills the surface with an image.
    """

    image: Optional[UriModel] = Field(
        None, description='The image to display on the surface.'
    )
    repeat: Optional[RepeatModel] = Field(
        '[1, 1]', description='The number of times the image repeats along each axis.'
    )
    color: Optional[Color] = Field(
        'white',
        description='The color of the image. This color value is multiplied with the image to produce the final color.',
    )
    transparent: Optional[BooleanModel] = Field(
        False, description='Whether or not the image has transparency.'
    )


class Point(BaseModel):
    """
    A point, or viewport-aligned circle.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the point is shown.'
    )
    pixelSize: Optional[Double] = Field(
        1.0, description='The size of the point, in pixels.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the point, which indicates if the position is relative to terrain or not.',
    )
    color: Optional[Color] = Field('white', description='The color of the point.')
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the outline of the point.'
    )
    outlineWidth: Optional[Double] = Field(
        0.0, description='The width of the outline of the point.'
    )
    scaleByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the point's scale should change based on the point's distance from the camera. This scalar value will be multiplied by `pixelSize`.",
    )
    translucencyByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the point's translucency should change based on the point's distance from the camera. This scalar value should range from 0 to 1.",
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this point will be displayed.',
    )
    disableDepthTestDistance: Optional[Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class PositionListOfListsModel(PositionListOfLists):
    """
    A list of lists of positions.
    """

    pass


class ClockModel(Clock):
    """
    Initial settings for a simulated clock when a document is loaded. The start and stop time are configured using the interval property.
    """

    pass


class ShapeModel(Shape):
    """
    A list of two-dimensional positions defining a shape.
    """

    pass


class FontModel(Font):
    """
    A font used to draw text. Fonts are specified using the same syntax as the CSS "font" property.
    """

    pass


class SolidColorMaterial(BaseModel):
    """
    A material that fills the surface with a solid color.
    """

    color: Optional[Color] = Field('white', description='The color of the surface.')


class PolylineOutlineMaterialModel(PolylineOutlineMaterial):
    """
    A material that fills the surface of a line with an outlined color.
    """

    pass


class OrientationModel(Orientation):
    """
    Defines an orientation. An orientation is a rotation that takes a vector expressed in the "body" axes of the object and transforms it to the Earth fixed axes.
    """

    pass


class CheckerboardMaterialModel(CheckerboardMaterial):
    """
    A material that fills the surface with a checkerboard pattern.
    """

    pass


class Billboard(BaseModel):
    """
    A billboard, or viewport-aligned image. The billboard is positioned in the scene by the `position` property. A billboard is sometimes called a marker.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the billboard is shown.'
    )
    image: Optional[UriModel] = Field(
        None,
        description='The URI of the image displayed on the billboard. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS). The URI may also be a <a href="https://developer.mozilla.org/en/data_URIs">data URI</a>.',
    )
    scale: Optional[Double] = Field(
        1.0,
        description="The scale of the billboard. The scale is multiplied with the pixel size of the billboard's `image`. For example, if the scale is 2.0, the billboard will be rendered with twice the number of pixels, in each direction, of the `image`.",
    )
    pixelOffset: Optional[PixelOffset] = Field(
        '[0.0, 0.0]',
        description='The offset, in viewport pixels, of the billboard origin from the `position`. A pixel offset is the number of pixels up and to the right to place the billboard, relative to the `position`.',
    )
    eyeOffset: Optional[EyeOffset] = Field(
        '[0.0, 0.0, 0.0]',
        description="The eye offset of the billboard, which is the offset in eye coordinates at which to place the billboard relative to the `position` property. Eye coordinates are a left-handed coordinate system where the X-axis points toward the viewer's right, the Y-axis points up, and the Z-axis points into the screen.",
    )
    horizontalOrigin: Optional[HorizontalOrigin] = Field(
        'CENTER',
        description='The horizontal origin of the billboard, which determines whether the billboard image is left-, center-, or right-aligned with the `position`.',
    )
    verticalOrigin: Optional[VerticalOrigin] = Field(
        'CENTER',
        description='The vertical origin of the billboard, which determines whether the billboard image is bottom-, center-, or top-aligned with the `position`.',
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the billboard, which indicates if the position is relative to terrain or not.',
    )
    color: Optional[Color] = Field(
        'white',
        description="The color of the billboard. This color value is multiplied with the values of the billboard's `image` to produce the final color.",
    )
    rotation: Optional[Double] = Field(
        0.0,
        description='The rotation of the billboard, in radians, counter-clockwise from the alignedAxis.',
    )
    alignedAxis: Optional[AlignedAxis] = Field(
        '[0.0, 0.0, 0.0]',
        description='The aligned axis is the unit vector, in world coordinates, that the billboard up vector points towards. The default is the zero vector, which means the billboard is aligned to the screen up vector.',
    )
    sizeInMeters: Optional[BooleanModel] = Field(
        False,
        description="Whether this billboard's size (`width` and `height`) should be measured in meters, otherwise size is measured in pixels.",
    )
    width: Optional[Double] = Field(
        None,
        description='The width of the billboard, in pixels (or meters, if `sizeInMeters` is true). By default, the native width of the image is used.',
    )
    height: Optional[Double] = Field(
        None,
        description='The height of the billboard, in pixels (or meters, if `sizeInMeters` is true). By default, the native height of the image is used.',
    )
    scaleByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the billboard's scale should change based on the billboard's distance from the camera. This scalar value will be multiplied by `scale`.",
    )
    translucencyByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the billboard's translucency should change based on the billboard's distance from the camera. This scalar value should range from 0 to 1.",
    )
    pixelOffsetScaleByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the billboard's pixel offset should change based on the billboard's distance from the camera. This scalar value will be multiplied by `pixelOffset`.",
    )
    imageSubRegion: Optional[BoundingRectangleModel] = Field(
        None,
        description='A sub-region of the image which will be used for the billboard, rather than the entire image, measured in pixels from the bottom-left.',
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this billboard will be displayed.',
    )
    disableDepthTestDistance: Optional[Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class Label(BaseModel):
    """
    A string of text.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the label is shown.'
    )
    text: Optional[String] = Field(
        None,
        description='The text displayed by the label. The newline character (\\n) indicates line breaks.',
    )
    font: Optional[FontModel] = Field(
        '30px sans-serif', description='The font to use for the label.'
    )
    style: Optional[LabelStyle] = Field('FILL', description='The style of the label.')
    scale: Optional[Double] = Field(
        1.0,
        description="The scale of the label. The scale is multiplied with the pixel size of the label's text. For example, if the scale is 2.0, the label will be rendered with twice the number of pixels, in each direction, of the text.",
    )
    showBackground: Optional[BooleanModel] = Field(
        False, description='Whether or not a background behind the label is shown.'
    )
    backgroundColor: Optional[Color] = Field(
        '[0.165, 0.165, 0.165, 0.8]',
        description='The color of the background behind the label.',
    )
    backgroundPadding: Optional[BackgroundPadding] = Field(
        '[7, 5]',
        description="The amount of padding between the text and the label's background.",
    )
    pixelOffset: Optional[PixelOffset] = Field(
        '[0.0, 0.0]',
        description='The offset, in viewport pixels, of the label origin from the `position`. A pixel offset is the number of pixels up and to the right to place the label, relative to the `position`.',
    )
    eyeOffset: Optional[EyeOffset] = Field(
        '[0.0, 0.0, 0.0]',
        description="The eye offset of the label, which is the offset in eye coordinates at which to place the label relative to the `position` property. Eye coordinates are a left-handed coordinate system where the X-axis points toward the viewer's right, the Y-axis points up, and the Z-axis points into the screen.",
    )
    horizontalOrigin: Optional[HorizontalOrigin] = Field(
        'CENTER',
        description='The horizontal origin of the label. It controls whether the label is left-, center-, or right-aligned with the `position`.',
    )
    verticalOrigin: Optional[VerticalOrigin] = Field(
        'CENTER',
        description='The vertical origin of the label. It controls whether the label image is bottom-, center-, or top-aligned with the `position`.',
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the label, which indicates if the position is relative to terrain or not.',
    )
    fillColor: Optional[Color] = Field(
        'white', description='The fill color of the label.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The outline color of the label.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The outline width of the label.'
    )
    translucencyByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the label's translucency should change based on the label's distance from the camera. This scalar value should range from 0 to 1.",
    )
    pixelOffsetScaleByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the label's pixel offset should change based on the label's distance from the camera. This scalar value will be multiplied by `pixelOffset`.",
    )
    scaleByDistance: Optional[NearFarScalar] = Field(
        None,
        description="How the label's scale should change based on the label's distance from the camera. This scalar value will be multiplied by `scale`.",
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this label will be displayed.',
    )
    disableDepthTestDistance: Optional[Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class Model(BaseModel):
    """
    A 3D model.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the model is shown.'
    )
    gltf: Optional[UriModel] = Field(
        None,
        description='The URI of a <a href="https://github.com/KhronosGroup/glTF">glTF</a> model. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS). The URI may also be a <a href="https://developer.mozilla.org/en/data_URIs">data URI</a>.',
    )
    scale: Optional[Double] = Field(1.0, description='The scale of the model.')
    minimumPixelSize: Optional[Double] = Field(
        0.0,
        description='The approximate minimum pixel size of the model regardless of zoom.',
    )
    maximumScale: Optional[Double] = Field(
        None,
        description='The maximum scale size of the model. This is used as an upper limit for `minimumPixelSize`.',
    )
    incrementallyLoadTextures: Optional[BooleanModel] = Field(
        True,
        description='Whether or not the model can be rendered before all textures have loaded.',
    )
    runAnimations: Optional[BooleanModel] = Field(
        True,
        description='Whether or not to run all animations defined in the glTF model.',
    )
    shadows: Optional[ShadowModeModel] = Field(
        'ENABLED', description='Whether or not the model casts or receives shadows.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the model, which indicates if the position is relative to terrain or not.',
    )
    silhouetteColor: Optional[Color] = Field(
        'red', description='The color of the silhouette drawn around the model.'
    )
    silhouetteSize: Optional[Double] = Field(
        0.0,
        description='The size, in pixels, of the silhouette drawn around the model.',
    )
    color: Optional[Color] = Field(
        'white', description="The color to blend with the model's rendered color."
    )
    colorBlendMode: Optional[ColorBlendModeModel] = Field(
        'HIGHLIGHT',
        description="The mode to use for blending between `color` and the model's color.",
    )
    colorBlendAmount: Optional[Double] = Field(
        0.5,
        description="The color strength when `colorBlendMode` is `MIX`. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.",
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this model will be displayed.',
    )
    nodeTransformations: Optional[NodeTransformations] = None
    articulations: Optional[Articulations] = None


class Tileset(BaseModel):
    """
    A 3D Tiles tileset.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the tileset is shown.'
    )
    uri: Optional[UriModel] = Field(
        None,
        description='The URI of a 3D tiles tileset. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS).',
    )
    maximumScreenSpaceError: Optional[Double] = Field(
        None,
        description='The maximum screen space error used to drive level of detail refinement.',
    )


class SensorVolumePortionToDisplay(BaseModel):
    """
    The part of a sensor that should be displayed.
    """

    portionToDisplay: Optional[SensorVolumePortionToDisplayValue] = Field(
        None, description='The part of a sensor to display.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The part of a sensor to display, specified as a reference to another property.',
    )


class Vector(BaseModel):
    """
    Defines a graphical vector that originates at the `position` property and extends in the provided direction for the provided length.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the vector is shown.'
    )
    color: Optional[ColorModel] = Field('white', description='The color of the vector.')
    direction: Optional[Direction] = Field(
        None, description='The direction of the vector.'
    )
    length: Optional[Double] = Field(
        1.0, description='The graphical length of the vector, in meters.'
    )
    minimumLengthInPixels: Optional[Double] = Field(
        0.0, description='The minimum graphical length of the vector in pixels.'
    )


class TilesetModel(Tileset):
    """
    A 3D Tiles tileset.
    """

    pass


class StripeMaterial(BaseModel):
    """
    A material that fills the surface with alternating colors.
    """

    orientation: Optional[StripeOrientation] = Field(
        'HORIZONTAL',
        description='The value indicating if the stripes are horizontal or vertical.',
    )
    evenColor: Optional[Color] = Field('white', description='The even color.')
    oddColor: Optional[Color] = Field('black', description='The odd color.')
    offset: Optional[Double] = Field(
        0.0,
        description='The value indicating where in the pattern to begin drawing, with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.',
    )
    repeat: Optional[Double] = Field(
        1.0, description='The number of times the stripes repeat.'
    )


class SolidColorMaterialModel(SolidColorMaterial):
    """
    A material that fills the surface with a solid color.
    """

    pass


class ImageMaterialModel(ImageMaterial):
    """
    A material that fills the surface with an image.
    """

    pass


class StripeMaterialModel(StripeMaterial):
    """
    A material that fills the surface with alternating colors.
    """

    pass


class PolylineMaterial(BaseModel):
    """
    A definition of how a polyline is colored or shaded.
    """

    solidColor: Optional[SolidColorMaterialModel] = Field(
        None,
        description='A material that fills the line with a solid color, which may be translucent.',
    )
    polylineOutline: Optional[PolylineOutlineMaterial] = Field(
        None, description='A material that fills the line with a color and outline.'
    )
    polylineArrow: Optional[PolylineArrowMaterial] = Field(
        None, description='A material that fills the line with an arrow.'
    )
    polylineDash: Optional[PolylineDashMaterial] = Field(
        None, description='A material that fills the line with a pattern of dashes.'
    )
    polylineGlow: Optional[PolylineGlowMaterial] = Field(
        None, description='A material that fills the line with a glowing color.'
    )
    image: Optional[ImageMaterialModel] = Field(
        None, description='A material that fills the line with an image.'
    )
    grid: Optional[GridMaterial] = Field(
        None, description='A material that fills the line with a grid.'
    )
    stripe: Optional[StripeMaterialModel] = Field(
        None, description='A material that fills the line with alternating colors.'
    )
    checkerboard: Optional[CheckerboardMaterial] = Field(
        None, description='A material that fills the line with a checkerboard pattern.'
    )


class ModelModel(Model):
    """
    A 3D model.
    """

    pass


class Polyline(BaseModel):
    """
    A polyline, which is a line in the scene composed of multiple segments.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the polyline is shown.'
    )
    positions: Optional[PositionList] = Field(
        None,
        description='The array of positions defining the polyline as a line strip.',
    )
    arcType: Optional[ArcType] = Field(
        'GEODESIC',
        description='The type of arc that should connect the positions of the polyline.',
    )
    width: Optional[Double] = Field(1.0, description='The width of the polyline.')
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    material: Optional[PolylineMaterial] = Field(
        'solid white', description='The material to use to draw the polyline.'
    )
    followSurface: Optional[BooleanModel] = Field(
        True,
        description='Whether or not the positions are connected as great arcs (the default) or as straight lines. This property has been superseded by `arcType`, which should be used instead.',
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the polyline casts or receives shadows.'
    )
    depthFailMaterial: Optional[PolylineMaterial] = Field(
        None,
        description='The material to use to draw the polyline when it is below the terrain.',
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this polyline will be displayed.',
    )
    clampToGround: Optional[BooleanModel] = Field(
        False,
        description='Whether or not the polyline should be clamped to the ground.',
    )
    classificationType: Optional[ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Integer] = Field(
        '0',
        description='The z-index of the polyline, used for ordering ground geometry. Only has an effect if the polyline is constant, and `clampToGround` is true.',
    )


class Material(BaseModel):
    """
    A definition of how a surface is colored or shaded.
    """

    solidColor: Optional[SolidColorMaterialModel] = Field(
        None,
        description='A material that fills the surface with a solid color, which may be translucent.',
    )
    image: Optional[ImageMaterialModel] = Field(
        None, description='A material that fills the surface with an image.'
    )
    grid: Optional[GridMaterial] = Field(
        None, description='A material that fills the surface with a grid.'
    )
    stripe: Optional[StripeMaterialModel] = Field(
        None, description='A material that fills the surface with alternating colors.'
    )
    checkerboard: Optional[CheckerboardMaterial] = Field(
        None,
        description='A material that fills the surface with a checkerboard pattern.',
    )


class Path(BaseModel):
    """
    A path, which is a polyline defined by the motion of an object over time. The possible vertices of the path are specified by the `position` property. Note that because clients cannot render a truly infinite path, the path must be limited, either by defining availability for this object, or by using the `leadTime` and `trailTime` properties.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the path is shown.'
    )
    leadTime: Optional[Double] = Field(
        None,
        description="The time ahead of the animation time, in seconds, to show the path. The time will be limited to not exceed the object's availability. By default, the value is unlimited, which effectively results in drawing the entire available path of the object.",
    )
    trailTime: Optional[Double] = Field(
        None,
        description="The time behind the animation time, in seconds, to show the path. The time will be limited to not exceed the object's availability. By default, the value is unlimited, which effectively results in drawing the entire available path of the object.",
    )
    width: Optional[Double] = Field(1.0, description='The width of the path line.')
    resolution: Optional[Double] = Field(
        60.0,
        description='The maximum step-size, in seconds, used to sample the path. If the `position` property has data points farther apart than resolution specifies, additional samples will be computed, creating a smoother path.',
    )
    material: Optional[PolylineMaterial] = Field(
        'solid white', description='The material to use to draw the path.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this path will be displayed.',
    )


class MaterialModel(Material):
    """
    A definition of how a surface is colored or shaded.
    """

    pass


class CustomPatternSensor(BaseModel):
    """
    A custom sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the entire custom sensor is shown.'
    )
    directions: Optional[DirectionList] = Field(
        None, description='The list of directions defining the custom sensor.'
    )
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[ColorModel] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[ColorModel] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[IntegerModel] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class RectangularSensor(BaseModel):
    """
    A rectangular pyramid sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True,
        description='Whether or not the entire rectangular pyramid sensor is shown.',
    )
    xHalfAngle: Optional[Double] = Field('π / 2', description='The X half angle.')
    yHalfAngle: Optional[Double] = Field('π / 2', description='The Y half angle.')
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[ColorModel] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[ColorModel] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[IntegerModel] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class Fan(BaseModel):
    """
    A fan, which starts at a point or apex and extends in a specified list of directions from the apex. Each pair of directions forms a face of the fan extending to the specified radius.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the fan is shown.'
    )
    directions: Optional[DirectionList] = Field(
        None, description='The list of directions defining the fan.'
    )
    radius: Optional[Double] = Field(
        None,
        description='The radial limit of the fan. If `perDirectionRadius` is false, then this value is required.',
    )
    perDirectionRadius: Optional[Boolean] = Field(
        False,
        description='Whether the magnitude of each direction is used instead of a constant radius.',
    )
    material: Optional[MaterialModel] = Field(
        'solid white', description='The material to display on the surface of the fan.'
    )
    fill: Optional[Boolean] = Field(
        True, description='Whether or not the fan is filled.'
    )
    outline: Optional[Boolean] = Field(
        False, description='Whether or not the fan is outlined.'
    )
    outlineColor: Optional[ColorModel] = Field(
        'black', description='The color of the fan outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the fan outline.'
    )
    numberOfRings: Optional[IntegerModel] = Field(
        6,
        description='The number of outline rings to draw, starting from the outer edge and equidistantly spaced towards the center.',
    )


class MaterialModel1(Material):
    """
    A definition of how a surface is colored or shaded.
    """

    pass


class Rectangle(BaseModel):
    """
    A cartographic rectangle, which conforms to the curvature of the globe and can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the rectangle is shown.'
    )
    coordinates: Optional[RectangleCoordinates] = Field(
        None, description='The coordinates of the rectangle.'
    )
    height: Optional[Double] = Field(0.0, description='The height of the rectangle.')
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the rectangle, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Double] = Field(
        None, description='The extruded height of the rectangle.'
    )
    extrudedHeightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The extruded height reference of the rectangle, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    rotation: Optional[Double] = Field(
        0.0, description='The rotation of the rectangle clockwise from north.'
    )
    stRotation: Optional[Double] = Field(
        0.0,
        description='The rotation of any applied texture. A positive rotation is counter-clockwise.',
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the rectangle is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white',
        description='The material to display on the surface of the rectangle.',
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the rectangle is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the rectangle outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the rectangle outline.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED',
        description='Whether or not the rectangle casts or receives shadows.',
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this rectangle will be displayed.',
    )
    classificationType: Optional[ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Integer] = Field(
        '0',
        description='The z-index of the rectangle, used for ordering ground geometry. Only has an effect if the rectangle is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Polygon(BaseModel):
    """
    A polygon, which is a closed figure on the surface of the Earth.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the polygon is shown.'
    )
    positions: Optional[PositionList] = Field(
        None, description='The array of positions defining a simple polygon.'
    )
    holes: Optional[PositionListOfListsModel] = Field(
        None,
        description='The array of arrays of positions defining holes in the polygon.',
    )
    arcType: Optional[ArcType] = Field(
        'GEODESIC',
        description='The type of arc that should connect the positions of the polygon.',
    )
    height: Optional[Double] = Field(
        0.0, description='The height of the polygon when `perPositionHeight` is false.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the polygon, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Double] = Field(
        None, description='The extruded height of the polygon.'
    )
    extrudedHeightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The extruded height reference of the polygon, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    stRotation: Optional[Double] = Field(
        0.0,
        description='The rotation of any applied texture. A positive rotation is counter-clockwise.',
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the polygon is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white', description='The material to use to fill the polygon.'
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the polygon is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the polygon outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the polygon outline.'
    )
    perPositionHeight: Optional[BooleanModel] = Field(
        False,
        description='Whether to use the height of each position to define the polygon or to use `height` as a constant height above the surface.',
    )
    closeTop: Optional[BooleanModel] = Field(
        True, description='Whether to close the top of the polygon.'
    )
    closeBottom: Optional[BooleanModel] = Field(
        True, description='Whether to close the bottom of the polygon.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the polygon casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this polygon will be displayed.',
    )
    classificationType: Optional[ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Integer] = Field(
        '0',
        description='The z-index of the polygon, used for ordering ground geometry. Only has an effect if the polygon is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Ellipse(BaseModel):
    """
    An ellipse, which is a closed curve on or above the surface of the Earth.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the ellipse is shown.'
    )
    semiMajorAxis: Optional[Double] = Field(
        None, description="The length of the ellipse's semi-major axis in meters."
    )
    semiMinorAxis: Optional[Double] = Field(
        None, description="The length of the ellipse's semi-minor axis in meters."
    )
    height: Optional[Double] = Field(
        '0.0', description='The altitude of the ellipse relative to the surface.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the ellipse, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Double] = Field(
        None,
        description="The altitude of the ellipse's extruded face relative to the surface.",
    )
    extrudedHeightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The extruded height reference of the ellipse, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    rotation: Optional[Double] = Field(
        '0.0', description='The angle from north (counter-clockwise) in radians.'
    )
    stRotation: Optional[Double] = Field(
        '0.0', description='The rotation of any applied texture coordinates.'
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the ellipse is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white', description='The material to use to fill the ellipse.'
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the ellipse is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the ellipse outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the ellipse outline.'
    )
    numberOfVerticalLines: Optional[Integer] = Field(
        '16',
        description='The number of vertical lines to use when outlining an extruded ellipse.',
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the ellipse casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this ellipse will be displayed.',
    )
    classificationType: Optional[ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Integer] = Field(
        '0',
        description='The z-index of the ellipse, used for ordering ground geometry. Only has an effect if the ellipse is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Corridor(BaseModel):
    """
    A corridor, which is a shape defined by a centerline and width that conforms to the curvature of the globe. It can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the corridor is shown.'
    )
    positions: Optional[PositionList] = Field(
        None,
        description='The array of positions defining the centerline of the corridor.',
    )
    width: Optional[Double] = Field(
        None,
        description='The width of the corridor, which is the distance between the edges of the corridor.',
    )
    height: Optional[Double] = Field(
        0.0,
        description='The height of the corridor, which is the altitude of the corridor relative to the surface.',
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the corridor, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Double] = Field(
        None,
        description="The extruded height of the corridor, which is the altitude of the corridor's extruded face relative to the surface.",
    )
    extrudedHeightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The extruded height reference of the corridor, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    cornerType: Optional[CornerType] = Field(
        'ROUNDED', description='The style of the corners of the corridor.'
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the corridor is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white',
        description='The material to display on the surface of the corridor.',
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the corridor is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the corridor outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the corridor outline.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the corridor casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this corridor will be displayed.',
    )
    classificationType: Optional[ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Integer] = Field(
        '0',
        description='The z-index of the corridor, used for ordering ground geometry. Only has an effect if the corridor is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Box(BaseModel):
    """
    A box, which is a closed rectangular cuboid.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the box is shown.'
    )
    dimensions: Optional[BoxDimensionsModel] = Field(
        None, description='The dimensions of the box.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the box, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the box is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white', description='The material to display on the surface of the box.'
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the box is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the box outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the box outline.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the box casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this box will be displayed.',
    )


class PolylineVolume(BaseModel):
    """
    A polyline with a volume, defined as a 2D shape extruded along a polyline that conforms to the curvature of the globe.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the volume is shown.'
    )
    positions: Optional[PositionList] = Field(
        None,
        description='The array of positions defining the center of the polyline volume.',
    )
    shape: Optional[ShapeModel] = Field(
        None,
        description='The array of positions defining the shape of the volume to be extruded.',
    )
    cornerType: Optional[CornerType] = Field(
        'ROUNDED', description='The style of the corners of the volume.'
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the volume is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white', description='The material to use to fill the volume.'
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the volume is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the volume outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the volume outline.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the volume casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this volume will be displayed.',
    )


class Ellipsoid(BaseModel):
    """
    A closed quadric surface that is a three-dimensional analogue of an ellipse.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the ellipsoid is shown.'
    )
    radii: Optional[EllipsoidRadii] = Field(
        None, description='The radii of the ellipsoid.'
    )
    innerRadii: Optional[EllipsoidRadii] = Field(
        None, description='The inner radii of the ellipsoid.'
    )
    minimumClock: Optional[Double] = Field(
        0.0, description='The minimum clock angle of the ellipsoid.'
    )
    maximumClock: Optional[Double] = Field(
        '2π', description='The maximum clock angle of the ellipsoid.'
    )
    minimumCone: Optional[Double] = Field(
        0.0, description='The minimum cone angle of the ellipsoid.'
    )
    maximumCone: Optional[Double] = Field(
        'π', description='The maximum cone angle of the ellipsoid.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the ellipsoid, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the ellipsoid is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white',
        description='The material to display on the surface of the ellipsoid.',
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the ellipsoid is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the ellipsoid outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the ellipsoid outline.'
    )
    stackPartitions: Optional[Integer] = Field(
        64, description='The number of times to partition the ellipsoid into stacks.'
    )
    slicePartitions: Optional[Integer] = Field(
        64,
        description='The number of times to partition the ellipsoid into radial slices.',
    )
    subdivisions: Optional[Integer] = Field(
        128,
        description='The number of samples per outline ring, determining the granularity of the curvature.',
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED',
        description='Whether or not the ellipsoid casts or receives shadows.',
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this ellipsoid will be displayed.',
    )


class CorridorModel(Corridor):
    """
    A corridor, which is a shape defined by a centerline and width that conforms to the curvature of the globe. It can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    pass


class Cylinder(BaseModel):
    """
    A cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the cylinder is shown.'
    )
    length: Optional[Double] = Field(None, description='The length of the cylinder.')
    topRadius: Optional[Double] = Field(
        None, description='The radius of the top of the cylinder.'
    )
    bottomRadius: Optional[Double] = Field(
        None, description='The radius of the bottom of the cylinder.'
    )
    heightReference: Optional[HeightReferenceModel] = Field(
        'NONE',
        description='The height reference of the cylinder, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the cylinder is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white',
        description='The material to display on the surface of the cylinder.',
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the cylinder is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the cylinder outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the cylinder outline.'
    )
    numberOfVerticalLines: Optional[Integer] = Field(
        16,
        description='The number of vertical lines to draw along the perimeter for the outline.',
    )
    slices: Optional[Integer] = Field(
        128, description='The number of edges around the perimeter of the cylinder.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the cylinder casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this cylinder will be displayed.',
    )


class EllipsoidModel(Ellipsoid):
    """
    A closed quadric surface that is a three-dimensional analogue of an ellipse.
    """

    pass


class PolylineVolumeModel(PolylineVolume):
    """
    A polyline with a volume, defined as a 2D shape extruded along a polyline that conforms to the curvature of the globe.
    """

    pass


class RectangleModel(Rectangle):
    """
    A cartographic rectangle, which conforms to the curvature of the globe and can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    pass


class Wall(BaseModel):
    """
    A two-dimensional wall defined as a line strip and optional maximum and minimum heights, which conforms to the curvature of the globe and can be placed along the surface or at altitude.
    """

    show: Optional[BooleanModel] = Field(
        True, description='Whether or not the wall is shown.'
    )
    positions: Optional[PositionList] = Field(
        None, description='The array of positions defining the centerline of the wall.'
    )
    minimumHeights: Optional[DoubleList] = Field(
        None,
        description='The list of heights to be used for the bottom of the wall, instead of the surface.',
    )
    maximumHeights: Optional[DoubleList] = Field(
        None,
        description='The list of heights to be used for the top of the wall, instead of the height of each position.',
    )
    granularity: Optional[Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[BooleanModel] = Field(
        True, description='Whether or not the wall is filled.'
    )
    material: Optional[MaterialModel1] = Field(
        'solid white', description='The material to display on the surface of the wall.'
    )
    outline: Optional[BooleanModel] = Field(
        False, description='Whether or not the wall is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the wall outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the wall outline.'
    )
    shadows: Optional[ShadowModeModel] = Field(
        'DISABLED', description='Whether or not the wall casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this wall will be displayed.',
    )


class ConicSensor(BaseModel):
    """
    A conical sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the entire conical sensor is shown.'
    )
    innerHalfAngle: Optional[Double] = Field(
        0.0, description='The inner half angle of the cone.'
    )
    outerHalfAngle: Optional[Double] = Field(
        'π', description='The outer half angle of the cone.'
    )
    minimumClockAngle: Optional[Double] = Field(
        0.0, description='The minimum clock angle limit of the cone.'
    )
    maximumClockAngle: Optional[Double] = Field(
        '2π', description='The maximum clock angle limit of the cone.'
    )
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[MaterialModel] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[MaterialModel] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[ColorModel] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[ColorModel] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[ColorModel] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[IntegerModel] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class Packet(BaseModel):
    """
    Describes the graphical properties of a single object in a scene, such as a single aircraft.
    """

    id: Optional[str] = Field(
        None,
        description='The ID of the object described by this packet. IDs do not need to be GUIDs, but they do need to uniquely identify a single object within a CZML source and any other CZML sources loaded into the same scope. If this property is not specified, the client will automatically generate a unique one. However, this prevents later packets from referring to this object in order to add more data to it.',
    )
    delete: Optional[bool] = Field(
        None,
        description='Whether the client should delete all existing data for this object, identified by ID. If true, all other properties in this packet will be ignored.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the object. It does not have to be unique and is intended for user consumption.',
    )
    parent: Optional[str] = Field(
        None, description='The ID of the parent object, if any.'
    )
    description: Optional[String] = Field(
        None, description='An HTML description of the object.'
    )
    clock: Optional[Clock] = Field(
        None,
        description='The clock settings for the entire data set. Only valid on the document object.',
    )
    version: Optional[str] = Field(
        None,
        description='The CZML version being written. Only valid on the document object.',
    )
    availability: Optional[TimeIntervalCollectionValue] = Field(
        '0000-00-00T00:00:00Z/9999-12-31T24:00:00Z',
        description='The set of time intervals over which data for an object is available. The property can be a single string specifying a single interval, or an array of strings representing intervals. A later CZML packet can update this availability if it changes or is found to be incorrect. For example, an SGP4 propagator may initially report availability for all time, but then later the propagator throws an exception and the availability can be adjusted to end at that time. If this optional property is not present, the object is assumed to be available for all time. Availability is scoped to a particular CZML stream, so two different streams can list different availability for a single object. Within a single stream, the last availability stated for an object is the one in effect and any availabilities in previous packets are ignored. If an object is not available at a time, the client will not draw that object.',
    )
    properties: Optional[CustomProperties] = Field(
        None, description='A set of custom properties for this object.'
    )
    position: Optional[Position] = Field(
        None,
        description='The position of the object in the world. The position has no direct visual representation, but it is used to locate billboards, labels, and other graphical items attached to the object.',
    )
    orientation: Optional[Orientation] = Field(
        None,
        description='The orientation of the object in the world. The orientation has no direct visual representation, but it is used to orient models, cones, pyramids, and other graphical items attached to the object.',
    )
    viewFrom: Optional[ViewFromModel] = Field(
        None,
        description="A suggested camera location when viewing this object. The property is specified as a Cartesian position in the East (x), North (y), Up (z) reference frame relative to the object's position.",
    )
    billboard: Optional[Billboard] = Field(
        None,
        description='A billboard, or viewport-aligned image, sometimes called a marker. The billboard is positioned in the scene by the `position` property.',
    )
    box: Optional[Box] = Field(
        None,
        description='A box, which is a closed rectangular cuboid. The box is positioned and oriented using the `position` and `orientation` properties.',
    )
    corridor: Optional[CorridorModel] = Field(
        None,
        description='A corridor, which is a shape defined by a centerline and width.',
    )
    cylinder: Optional[Cylinder] = Field(
        None,
        description='A cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius. The cylinder is positioned and oriented using the `position` and `orientation` properties.',
    )
    ellipse: Optional[Ellipse] = Field(
        None,
        description='An ellipse, which is a closed curve on the surface of the Earth. The ellipse is positioned using the `position` property.',
    )
    ellipsoid: Optional[EllipsoidModel] = Field(
        None,
        description='An ellipsoid, which is a closed quadric surface that is a three-dimensional analogue of an ellipse. The ellipsoid is positioned and oriented using the `position` and `orientation` properties.',
    )
    label: Optional[Label] = Field(
        None,
        description='A string of text. The label is positioned in the scene by the `position` property.',
    )
    model: Optional[Model] = Field(
        None,
        description='A 3D model. The model is positioned and oriented using the `position` and `orientation` properties.',
    )
    path: Optional[Path] = Field(
        None,
        description='A path, which is a polyline defined by the motion of an object over time. The possible vertices of the path are specified by the `position` property.',
    )
    point: Optional[Point] = Field(
        None,
        description='A point, or viewport-aligned circle. The point is positioned in the scene by the `position` property.',
    )
    polygon: Optional[Polygon] = Field(
        None,
        description='A polygon, which is a closed figure on the surface of the Earth.',
    )
    polyline: Optional[Polyline] = Field(
        None,
        description='A polyline, which is a line in the scene composed of multiple segments.',
    )
    polylineVolume: Optional[PolylineVolumeModel] = Field(
        None,
        description='A polyline with a volume, defined as a 2D shape extruded along a polyline.',
    )
    rectangle: Optional[RectangleModel] = Field(
        None,
        description='A cartographic rectangle, which conforms to the curvature of the globe and can be placed along the surface or at altitude.',
    )
    tileset: Optional[Tileset] = Field(None, description='A 3D Tiles tileset.')
    wall: Optional[Wall] = Field(
        None,
        description='A two-dimensional wall which conforms to the curvature of the globe and can be placed along the surface or at altitude.',
    )
    agi_conicSensor: Optional[ConicSensor] = Field(
        None,
        description='A conical sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_customPatternSensor: Optional[CustomPatternSensor] = Field(
        None,
        description='A custom sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_rectangularSensor: Optional[RectangularSensor] = Field(
        None,
        description='A rectangular pyramid sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_fan: Optional[Fan] = Field(
        None,
        description='Defines a fan, which starts at a point or apex and extends in a specified list of directions from the apex. Each pair of directions forms a face of the fan extending to the specified radius. The fan is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_vector: Optional[Vector] = Field(
        None,
        description='Defines a graphical vector that originates at the `position` property and extends in the provided direction for the provided length. The vector is positioned using the `position` property.',
    )


class PacketModel(Packet):
    """
    Describes the graphical properties of a single object in a scene, such as a single aircraft.
    """

    pass


class Document(BaseModel):
    """
    Describes a CZML document.
    """

    __root__: List[PacketModel] = Field(
        ..., description='Describes a CZML document.', title='Document'
    )

