# generated by datamodel-codegen:
#   filename:  Document.json
#   timestamp: 2021-03-29T05:46:25+00:00

from __future__ import annotations

from typing import Any, List, Optional, Union

from pydantic import BaseModel, Extra, Field

from . import (
    Box,
    Clock,
    Corridor,
    CustomProperty,
    Cylinder,
    DoubleList,
    Ellipsoid,
    Integer,
    Label,
    LabelStyle,
    Model,
    NodeTransformation,
    Orientation,
    Path,
    Point,
    Polygon,
    PolylineVolume,
    Position,
    Rectangle,
)


class Clock(BaseModel):
    """
    Initial settings for a simulated clock when a document is loaded. The start and stop time are configured using the interval property.
    """

    currentTime: Optional[Clock.TimeValue] = Field(
        None, description='The current time, specified in ISO8601 format.'
    )
    multiplier: Optional[float] = Field(
        1.0,
        description='The multiplier. When `step` is set to `TICK_DEPENDENT`, this is the number of seconds to advance each tick. When `step` is set to `SYSTEM_CLOCK_DEPENDENT`, this is multiplied by the elapsed system time between ticks. This value is ignored in `SYSTEM_CLOCK` mode.',
    )
    range: Optional[Clock.ClockRangeValue] = Field(
        'LOOP_STOP',
        description='The behavior when the current time reaches its start or end times.',
    )
    step: Optional[Clock.ClockStepValue] = Field(
        'SYSTEM_CLOCK_MULTIPLIER',
        description='How the current time advances each tick.',
    )


class TimeIntervalCollectionValue(BaseModel):
    __root__: Union[List[Any], str] = Field(
        ...,
        description='A collection of time intervals, specified in ISO8601 interval format.',
    )


class CustomProperties(BaseModel):
    """
    A set of custom properties.
    """

    pass

    class Config:
        extra = Extra.allow


class Position(BaseModel):
    """
    Defines a position. The position can optionally vary over time.
    """

    referenceFrame: Optional[str] = Field(
        'FIXED',
        description='The reference frame in which cartesian positions are specified. Possible values are "FIXED" and "INERTIAL".',
    )
    cartesian: Optional[Position.Cartesian3Value] = Field(
        None,
        description='The position specified as a three-dimensional Cartesian value, `[X, Y, Z]`, in meters relative to the `referenceFrame`.',
    )
    cartographicRadians: Optional[Position.CartographicRadiansValue] = Field(
        None,
        description='The position specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in radians and Height is in meters.',
    )
    cartographicDegrees: Optional[Position.CartographicDegreesValue] = Field(
        None,
        description='The position specified in Cartographic WGS84 coordinates, `[Longitude, Latitude, Height]`, where Longitude and Latitude are in degrees and Height is in meters.',
    )
    cartesianVelocity: Optional[Position.Cartesian3VelocityValue] = Field(
        None,
        description='The position and velocity specified as a three-dimensional Cartesian value and its derivative, `[X, Y, Z, dX, dY, dZ]`, in meters relative to the `referenceFrame`.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The position specified as a reference to another property.'
    )


class Orientation(BaseModel):
    """
    Defines an orientation. An orientation is a rotation that takes a vector expressed in the "body" axes of the object and transforms it to the Earth fixed axes.
    """

    unitQuaternion: Optional[NodeTransformation.UnitQuaternionValue] = Field(
        None,
        description='The orientation specified as a 4-dimensional unit magnitude quaternion, specified as `[X, Y, Z, W]`.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None,
        description='The orientation specified as a reference to another property.',
    )
    velocityReference: Optional[Orientation.VelocityReferenceValue] = Field(
        None,
        description='The orientation specified as the normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class ViewFrom(BaseModel):
    """
    A suggested initial camera position offset when tracking this object, specified as a Cartesian position. Typically defined in the East (x), North (y), Up (z) reference frame relative to the object's position, but may use another frame depending on the object's velocity.
    """

    cartesian: Optional[Position.Cartesian3Value] = Field(
        None,
        description='The offset specified as a three-dimensional Cartesian value `[X, Y, Z]`.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The offset specified as a reference to another property.'
    )


class AlignedAxis(BaseModel):
    """
    An aligned axis represented by a unit vector which can optionally vary over time.
    """

    unitCartesian: Optional[CustomProperty.UnitCartesian3Value] = Field(
        None,
        description='The axis specified as a three-dimensional unit magnitude Cartesian value `[X, Y, Z]`, in world coordinates.',
    )
    unitSpherical: Optional[CustomProperty.UnitSphericalValue] = Field(
        None,
        description='The axis specified as a unit spherical value `[Clock, Cone]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The axis specified as a reference to another property.'
    )
    velocityReference: Optional[Orientation.VelocityReferenceValue] = Field(
        None,
        description='The axis specified as the normalized velocity vector of a position property. The reference must be to a `position` property.',
    )


class BoundingRectangle(BaseModel):
    """
    A bounding rectangle specified by a corner, width and height.
    """

    boundingRectangle: Optional[CustomProperty.BoundingRectangleValue] = Field(
        None, description='The bounding rectangle specified as `[X, Y, Width, Height]`.'
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None,
        description='The bounding rectangle specified as a reference to another property.',
    )


class DoubleList(BaseModel):
    """
    A list of floating-point numbers.
    """

    array: Optional[DoubleList.DoubleListValue] = Field(
        None, description='The list of values specified as an array of numbers.'
    )
    references: Optional[Polygon.ReferenceListValue] = Field(
        None,
        description='The list of values specified as references. Each reference is to a property that defines a single value, which may change with time.',
    )


class Boolean(BaseModel):
    """
    A boolean value.
    """

    boolean: Optional[Cylinder.BooleanValue] = Field(
        None, description='The boolean value.'
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The boolean specified as a reference to another property.'
    )


class Double(BaseModel):
    """
    A floating-point number.
    """

    number: Optional[Cylinder.DoubleValue] = Field(None, description='The number.')
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The number specified as a reference to another property.'
    )


class Color(BaseModel):
    """
    A color. The color can optionally vary over time.
    """

    rgba: Optional[Cylinder.RgbaValue] = Field(
        None,
        description='The color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is an integer in the range 0-255.',
    )
    rgbaf: Optional[Cylinder.RgbafValue] = Field(
        None,
        description='The color specified as an array of color components `[Red, Green, Blue, Alpha]` where each component is a double in the range 0.0-1.0.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The color specified as a reference to another property.'
    )


class DeletableProperty(BaseModel):
    """
    The base schema for a property whose value may be deleted.
    """

    delete: Optional[bool] = Field(
        None,
        description='Whether the client should delete existing samples or interval data for this property. Data will be deleted for the containing interval, or if there is no containing interval, then all data. If true, all other properties in this property will be ignored.',
    )


class SensorVolumePortionToDisplayValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a part of a sensor that should be displayed.',
    )


class ReferenceValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a reference to another property.',
    )


class SensorVolumePortionToDisplayValue(BaseModel):
    __root__: str = Field(..., description='What part of a sensor should be displayed.')


class ReferenceValue(BaseModel):
    __root__: str = Field(
        ...,
        description='Represents a reference to another property. References can be used to specify that two properties on different objects are in fact, the same property.',
    )


class Integer(BaseModel):
    """
    An integer number.
    """

    number: Optional[Integer.IntegerValue] = Field(None, description='The integer.')
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The integer specified as a reference to another property.'
    )


class SphericalListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of spherical values.',
    )


class UnitSphericalListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of unit spherical values.',
    )


class UnitCartesian3ListValueProperty(BaseModel):
    __root__: Any = Field(
        ...,
        description='The base schema for a property whose value may be written as a list of three-dimensional unit magnitude Cartesian values.',
    )


class SphericalListValue(BaseModel):
    """
    A list of spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
        title='SphericalList',
    )


class UnitSphericalListValue(BaseModel):
    """
    A list of unit spherical values specified as `[Clock, Cone, Clock, Cone, ...]` angles.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of unit spherical values specified as `[Clock, Cone, Clock, Cone, ...]` angles.',
        title='UnitSphericalList',
    )


class UnitCartesian3ListValue(BaseModel):
    """
    A list of three-dimensional unit magnitude Cartesian values, specified as `[X, Y, Z, X, Y, Z, ...]`.
    """

    __root__: List[float] = Field(
        ...,
        description='A list of three-dimensional unit magnitude Cartesian values, specified as `[X, Y, Z, X, Y, Z, ...]`.',
        title='UnitCartesian3List',
    )


class Direction(BaseModel):
    """
    A unit vector, in world coordinates, that defines a direction.
    """

    spherical: Optional[CustomProperty.SphericalValue] = Field(
        None,
        description='The direction specified as a spherical value `[Clock, Cone, Magnitude]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    unitSpherical: Optional[CustomProperty.UnitSphericalValue] = Field(
        None,
        description='The direction specified as a unit spherical value `[Clock, Cone]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    cartesian: Optional[Position.Cartesian3Value] = Field(
        None,
        description='The direction specified as a three-dimensional Cartesian value `[X, Y, Z]`, in world coordinates in meters.',
    )
    unitCartesian: Optional[CustomProperty.UnitCartesian3Value] = Field(
        None,
        description='The direction specified as a three-dimensional unit magnitude Cartesian value `[X, Y, Z]`, in world coordinates in meters.',
    )
    reference: Optional[LabelStyle.ReferenceValue] = Field(
        None, description='The direction specified as a reference to another property.'
    )


class Billboard(BaseModel):
    """
    A billboard, or viewport-aligned image. The billboard is positioned in the scene by the `position` property. A billboard is sometimes called a marker.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the billboard is shown.'
    )
    image: Optional[Cylinder.Uri] = Field(
        None,
        description='The URI of the image displayed on the billboard. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS). The URI may also be a <a href="https://developer.mozilla.org/en/data_URIs">data URI</a>.',
    )
    scale: Optional[Cylinder.Double] = Field(
        1.0,
        description="The scale of the billboard. The scale is multiplied with the pixel size of the billboard's `image`. For example, if the scale is 2.0, the billboard will be rendered with twice the number of pixels, in each direction, of the `image`.",
    )
    pixelOffset: Optional[Label.PixelOffset] = Field(
        '[0.0, 0.0]',
        description='The offset, in viewport pixels, of the billboard origin from the `position`. A pixel offset is the number of pixels up and to the right to place the billboard, relative to the `position`.',
    )
    eyeOffset: Optional[Label.EyeOffset] = Field(
        '[0.0, 0.0, 0.0]',
        description="The eye offset of the billboard, which is the offset in eye coordinates at which to place the billboard relative to the `position` property. Eye coordinates are a left-handed coordinate system where the X-axis points toward the viewer's right, the Y-axis points up, and the Z-axis points into the screen.",
    )
    horizontalOrigin: Optional[Label.HorizontalOrigin] = Field(
        'CENTER',
        description='The horizontal origin of the billboard, which determines whether the billboard image is left-, center-, or right-aligned with the `position`.',
    )
    verticalOrigin: Optional[Label.VerticalOrigin] = Field(
        'CENTER',
        description='The vertical origin of the billboard, which determines whether the billboard image is bottom-, center-, or top-aligned with the `position`.',
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the billboard, which indicates if the position is relative to terrain or not.',
    )
    color: Optional[Cylinder.Color] = Field(
        'white',
        description="The color of the billboard. This color value is multiplied with the values of the billboard's `image` to produce the final color.",
    )
    rotation: Optional[Cylinder.Double] = Field(
        0.0,
        description='The rotation of the billboard, in radians, counter-clockwise from the alignedAxis.',
    )
    alignedAxis: Optional[AlignedAxis] = Field(
        '[0.0, 0.0, 0.0]',
        description='The aligned axis is the unit vector, in world coordinates, that the billboard up vector points towards. The default is the zero vector, which means the billboard is aligned to the screen up vector.',
    )
    sizeInMeters: Optional[Cylinder.Boolean] = Field(
        False,
        description="Whether this billboard's size (`width` and `height`) should be measured in meters, otherwise size is measured in pixels.",
    )
    width: Optional[Cylinder.Double] = Field(
        None,
        description='The width of the billboard, in pixels (or meters, if `sizeInMeters` is true). By default, the native width of the image is used.',
    )
    height: Optional[Cylinder.Double] = Field(
        None,
        description='The height of the billboard, in pixels (or meters, if `sizeInMeters` is true). By default, the native height of the image is used.',
    )
    scaleByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the billboard's scale should change based on the billboard's distance from the camera. This scalar value will be multiplied by `scale`.",
    )
    translucencyByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the billboard's translucency should change based on the billboard's distance from the camera. This scalar value should range from 0 to 1.",
    )
    pixelOffsetScaleByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the billboard's pixel offset should change based on the billboard's distance from the camera. This scalar value will be multiplied by `pixelOffset`.",
    )
    imageSubRegion: Optional[BoundingRectangle] = Field(
        None,
        description='A sub-region of the image which will be used for the billboard, rather than the entire image, measured in pixels from the bottom-left.',
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this billboard will be displayed.',
    )
    disableDepthTestDistance: Optional[Cylinder.Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class Label(BaseModel):
    """
    A string of text.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the label is shown.'
    )
    text: Optional[Label.String] = Field(
        None,
        description='The text displayed by the label. The newline character (\\n) indicates line breaks.',
    )
    font: Optional[Label.Font] = Field(
        '30px sans-serif', description='The font to use for the label.'
    )
    style: Optional[Label.LabelStyle] = Field(
        'FILL', description='The style of the label.'
    )
    scale: Optional[Cylinder.Double] = Field(
        1.0,
        description="The scale of the label. The scale is multiplied with the pixel size of the label's text. For example, if the scale is 2.0, the label will be rendered with twice the number of pixels, in each direction, of the text.",
    )
    showBackground: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not a background behind the label is shown.'
    )
    backgroundColor: Optional[Cylinder.Color] = Field(
        '[0.165, 0.165, 0.165, 0.8]',
        description='The color of the background behind the label.',
    )
    backgroundPadding: Optional[Label.BackgroundPadding] = Field(
        '[7, 5]',
        description="The amount of padding between the text and the label's background.",
    )
    pixelOffset: Optional[Label.PixelOffset] = Field(
        '[0.0, 0.0]',
        description='The offset, in viewport pixels, of the label origin from the `position`. A pixel offset is the number of pixels up and to the right to place the label, relative to the `position`.',
    )
    eyeOffset: Optional[Label.EyeOffset] = Field(
        '[0.0, 0.0, 0.0]',
        description="The eye offset of the label, which is the offset in eye coordinates at which to place the label relative to the `position` property. Eye coordinates are a left-handed coordinate system where the X-axis points toward the viewer's right, the Y-axis points up, and the Z-axis points into the screen.",
    )
    horizontalOrigin: Optional[Label.HorizontalOrigin] = Field(
        'CENTER',
        description='The horizontal origin of the label. It controls whether the label is left-, center-, or right-aligned with the `position`.',
    )
    verticalOrigin: Optional[Label.VerticalOrigin] = Field(
        'CENTER',
        description='The vertical origin of the label. It controls whether the label image is bottom-, center-, or top-aligned with the `position`.',
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the label, which indicates if the position is relative to terrain or not.',
    )
    fillColor: Optional[Cylinder.Color] = Field(
        'white', description='The fill color of the label.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The outline color of the label.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The outline width of the label.'
    )
    translucencyByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the label's translucency should change based on the label's distance from the camera. This scalar value should range from 0 to 1.",
    )
    pixelOffsetScaleByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the label's pixel offset should change based on the label's distance from the camera. This scalar value will be multiplied by `pixelOffset`.",
    )
    scaleByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the label's scale should change based on the label's distance from the camera. This scalar value will be multiplied by `scale`.",
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this label will be displayed.',
    )
    disableDepthTestDistance: Optional[Cylinder.Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class Model(BaseModel):
    """
    A 3D model.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the model is shown.'
    )
    gltf: Optional[Cylinder.Uri] = Field(
        None,
        description='The URI of a <a href="https://github.com/KhronosGroup/glTF">glTF</a> model. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS). The URI may also be a <a href="https://developer.mozilla.org/en/data_URIs">data URI</a>.',
    )
    scale: Optional[Cylinder.Double] = Field(1.0, description='The scale of the model.')
    minimumPixelSize: Optional[Cylinder.Double] = Field(
        0.0,
        description='The approximate minimum pixel size of the model regardless of zoom.',
    )
    maximumScale: Optional[Cylinder.Double] = Field(
        None,
        description='The maximum scale size of the model. This is used as an upper limit for `minimumPixelSize`.',
    )
    incrementallyLoadTextures: Optional[Cylinder.Boolean] = Field(
        True,
        description='Whether or not the model can be rendered before all textures have loaded.',
    )
    runAnimations: Optional[Cylinder.Boolean] = Field(
        True,
        description='Whether or not to run all animations defined in the glTF model.',
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'ENABLED', description='Whether or not the model casts or receives shadows.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the model, which indicates if the position is relative to terrain or not.',
    )
    silhouetteColor: Optional[Cylinder.Color] = Field(
        'red', description='The color of the silhouette drawn around the model.'
    )
    silhouetteSize: Optional[Cylinder.Double] = Field(
        0.0,
        description='The size, in pixels, of the silhouette drawn around the model.',
    )
    color: Optional[Cylinder.Color] = Field(
        'white', description="The color to blend with the model's rendered color."
    )
    colorBlendMode: Optional[Model.ColorBlendMode] = Field(
        'HIGHLIGHT',
        description="The mode to use for blending between `color` and the model's color.",
    )
    colorBlendAmount: Optional[Cylinder.Double] = Field(
        0.5,
        description="The color strength when `colorBlendMode` is `MIX`. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.",
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this model will be displayed.',
    )
    nodeTransformations: Optional[Model.NodeTransformations] = None
    articulations: Optional[Model.Articulations] = None


class Point(BaseModel):
    """
    A point, or viewport-aligned circle.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the point is shown.'
    )
    pixelSize: Optional[Cylinder.Double] = Field(
        1.0, description='The size of the point, in pixels.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the point, which indicates if the position is relative to terrain or not.',
    )
    color: Optional[Cylinder.Color] = Field(
        'white', description='The color of the point.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the outline of the point.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        0.0, description='The width of the outline of the point.'
    )
    scaleByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the point's scale should change based on the point's distance from the camera. This scalar value will be multiplied by `pixelSize`.",
    )
    translucencyByDistance: Optional[Point.NearFarScalar] = Field(
        None,
        description="How the point's translucency should change based on the point's distance from the camera. This scalar value should range from 0 to 1.",
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this point will be displayed.',
    )
    disableDepthTestDistance: Optional[Cylinder.Double] = Field(
        0.0,
        description='The distance from the camera at which to disable the depth test. This can be used to prevent clipping against terrain, for example. When set to zero, the depth test is always applied. When set to Infinity, the depth test is never applied.',
    )


class Tileset(BaseModel):
    """
    A 3D Tiles tileset.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the tileset is shown.'
    )
    uri: Optional[Cylinder.Uri] = Field(
        None,
        description='The URI of a 3D tiles tileset. For broadest client compatibility, the URI should be accessible via Cross-Origin Resource Sharing (CORS).',
    )
    maximumScreenSpaceError: Optional[Cylinder.Double] = Field(
        None,
        description='The maximum screen space error used to drive level of detail refinement.',
    )


class SensorVolumePortionToDisplay(BaseModel):
    """
    The part of a sensor that should be displayed.
    """

    portionToDisplay: Optional[SensorVolumePortionToDisplayValue] = Field(
        None, description='The part of a sensor to display.'
    )
    reference: Optional[ReferenceValue] = Field(
        None,
        description='The part of a sensor to display, specified as a reference to another property.',
    )


class DirectionList(BaseModel):
    """
    A list of directions.
    """

    spherical: Optional[SphericalListValue] = Field(
        None,
        description='The list of directions specified as spherical values `[Clock, Cone, Magnitude, Clock, Cone, Magnitude, ...]`, with angles in radians and magnitude in meters. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    unitSpherical: Optional[UnitSphericalListValue] = Field(
        None,
        description='The list of directions specified as unit spherical values `[Clock, Cone, Clock, Cone, ...]`, in radians. The clock angle is measured in the XY plane from the positive X axis toward the positive Y axis. The cone angle is the angle from the positive Z axis toward the negative Z axis.',
    )
    cartesian: Optional[Polygon.Cartesian3ListValue] = Field(
        None,
        description='The list of directions specified as three-dimensional Cartesian values `[X, Y, Z, X, Y, Z, ...]`, in world coordinates in meters.',
    )
    unitCartesian: Optional[UnitCartesian3ListValue] = Field(
        None,
        description='The list of directions specified as three-dimensional unit magnitude Cartesian values, `[X, Y, Z, X, Y, Z, ...]`, in world coordinates in meters.',
    )


class Vector(BaseModel):
    """
    Defines a graphical vector that originates at the `position` property and extends in the provided direction for the provided length.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the vector is shown.'
    )
    color: Optional[Color] = Field('white', description='The color of the vector.')
    direction: Optional[Direction] = Field(
        None, description='The direction of the vector.'
    )
    length: Optional[Double] = Field(
        1.0, description='The graphical length of the vector, in meters.'
    )
    minimumLengthInPixels: Optional[Double] = Field(
        0.0, description='The minimum graphical length of the vector in pixels.'
    )


class Path(BaseModel):
    """
    A path, which is a polyline defined by the motion of an object over time. The possible vertices of the path are specified by the `position` property. Note that because clients cannot render a truly infinite path, the path must be limited, either by defining availability for this object, or by using the `leadTime` and `trailTime` properties.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the path is shown.'
    )
    leadTime: Optional[Cylinder.Double] = Field(
        None,
        description="The time ahead of the animation time, in seconds, to show the path. The time will be limited to not exceed the object's availability. By default, the value is unlimited, which effectively results in drawing the entire available path of the object.",
    )
    trailTime: Optional[Cylinder.Double] = Field(
        None,
        description="The time behind the animation time, in seconds, to show the path. The time will be limited to not exceed the object's availability. By default, the value is unlimited, which effectively results in drawing the entire available path of the object.",
    )
    width: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the path line.'
    )
    resolution: Optional[Cylinder.Double] = Field(
        60.0,
        description='The maximum step-size, in seconds, used to sample the path. If the `position` property has data points farther apart than resolution specifies, additional samples will be computed, creating a smoother path.',
    )
    material: Optional[Path.PolylineMaterial] = Field(
        'solid white', description='The material to use to draw the path.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this path will be displayed.',
    )


class Polyline(BaseModel):
    """
    A polyline, which is a line in the scene composed of multiple segments.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the polyline is shown.'
    )
    positions: Optional[Polygon.PositionList] = Field(
        None,
        description='The array of positions defining the polyline as a line strip.',
    )
    arcType: Optional[Polygon.ArcType] = Field(
        'GEODESIC',
        description='The type of arc that should connect the positions of the polyline.',
    )
    width: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the polyline.'
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    material: Optional[Path.PolylineMaterial] = Field(
        'solid white', description='The material to use to draw the polyline.'
    )
    followSurface: Optional[Cylinder.Boolean] = Field(
        True,
        description='Whether or not the positions are connected as great arcs (the default) or as straight lines. This property has been superseded by `arcType`, which should be used instead.',
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the polyline casts or receives shadows.'
    )
    depthFailMaterial: Optional[Path.PolylineMaterial] = Field(
        None,
        description='The material to use to draw the polyline when it is below the terrain.',
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this polyline will be displayed.',
    )
    clampToGround: Optional[Cylinder.Boolean] = Field(
        False,
        description='Whether or not the polyline should be clamped to the ground.',
    )
    classificationType: Optional[Rectangle.ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Cylinder.Integer] = Field(
        '0',
        description='The z-index of the polyline, used for ordering ground geometry. Only has an effect if the polyline is constant, and `clampToGround` is true.',
    )


class Material(BaseModel):
    """
    A definition of how a surface is colored or shaded.
    """

    solidColor: Optional[Cylinder.SolidColorMaterial] = Field(
        None,
        description='A material that fills the surface with a solid color, which may be translucent.',
    )
    image: Optional[Cylinder.ImageMaterial] = Field(
        None, description='A material that fills the surface with an image.'
    )
    grid: Optional[Cylinder.GridMaterial] = Field(
        None, description='A material that fills the surface with a grid.'
    )
    stripe: Optional[Cylinder.StripeMaterial] = Field(
        None, description='A material that fills the surface with alternating colors.'
    )
    checkerboard: Optional[Cylinder.CheckerboardMaterial] = Field(
        None,
        description='A material that fills the surface with a checkerboard pattern.',
    )


class CustomPatternSensor(BaseModel):
    """
    A custom sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the entire custom sensor is shown.'
    )
    directions: Optional[DirectionList] = Field(
        None, description='The list of directions defining the custom sensor.'
    )
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[Material] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[Material] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[Color] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[Color] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[Integer] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class RectangularSensor(BaseModel):
    """
    A rectangular pyramid sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True,
        description='Whether or not the entire rectangular pyramid sensor is shown.',
    )
    xHalfAngle: Optional[Double] = Field('π / 2', description='The X half angle.')
    yHalfAngle: Optional[Double] = Field('π / 2', description='The Y half angle.')
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[Material] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[Material] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[Color] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[Color] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[Integer] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class Fan(BaseModel):
    """
    A fan, which starts at a point or apex and extends in a specified list of directions from the apex. Each pair of directions forms a face of the fan extending to the specified radius.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the fan is shown.'
    )
    directions: Optional[DirectionList] = Field(
        None, description='The list of directions defining the fan.'
    )
    radius: Optional[Double] = Field(
        None,
        description='The radial limit of the fan. If `perDirectionRadius` is false, then this value is required.',
    )
    perDirectionRadius: Optional[Boolean] = Field(
        False,
        description='Whether the magnitude of each direction is used instead of a constant radius.',
    )
    material: Optional[Material] = Field(
        'solid white', description='The material to display on the surface of the fan.'
    )
    fill: Optional[Boolean] = Field(
        True, description='Whether or not the fan is filled.'
    )
    outline: Optional[Boolean] = Field(
        False, description='Whether or not the fan is outlined.'
    )
    outlineColor: Optional[Color] = Field(
        'black', description='The color of the fan outline.'
    )
    outlineWidth: Optional[Double] = Field(
        1.0, description='The width of the fan outline.'
    )
    numberOfRings: Optional[Integer] = Field(
        6,
        description='The number of outline rings to draw, starting from the outer edge and equidistantly spaced towards the center.',
    )


class Box(BaseModel):
    """
    A box, which is a closed rectangular cuboid.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the box is shown.'
    )
    dimensions: Optional[Box.BoxDimensions] = Field(
        None, description='The dimensions of the box.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the box, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the box is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white', description='The material to display on the surface of the box.'
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the box is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the box outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the box outline.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the box casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this box will be displayed.',
    )


class Corridor(BaseModel):
    """
    A corridor, which is a shape defined by a centerline and width that conforms to the curvature of the globe. It can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the corridor is shown.'
    )
    positions: Optional[Polygon.PositionList] = Field(
        None,
        description='The array of positions defining the centerline of the corridor.',
    )
    width: Optional[Cylinder.Double] = Field(
        None,
        description='The width of the corridor, which is the distance between the edges of the corridor.',
    )
    height: Optional[Cylinder.Double] = Field(
        0.0,
        description='The height of the corridor, which is the altitude of the corridor relative to the surface.',
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the corridor, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Cylinder.Double] = Field(
        None,
        description="The extruded height of the corridor, which is the altitude of the corridor's extruded face relative to the surface.",
    )
    extrudedHeightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The extruded height reference of the corridor, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    cornerType: Optional[Corridor.CornerType] = Field(
        'ROUNDED', description='The style of the corners of the corridor.'
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the corridor is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white',
        description='The material to display on the surface of the corridor.',
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the corridor is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the corridor outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the corridor outline.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the corridor casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this corridor will be displayed.',
    )
    classificationType: Optional[Rectangle.ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Cylinder.Integer] = Field(
        '0',
        description='The z-index of the corridor, used for ordering ground geometry. Only has an effect if the corridor is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Cylinder(BaseModel):
    """
    A cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the cylinder is shown.'
    )
    length: Optional[Cylinder.Double] = Field(
        None, description='The length of the cylinder.'
    )
    topRadius: Optional[Cylinder.Double] = Field(
        None, description='The radius of the top of the cylinder.'
    )
    bottomRadius: Optional[Cylinder.Double] = Field(
        None, description='The radius of the bottom of the cylinder.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the cylinder, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the cylinder is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white',
        description='The material to display on the surface of the cylinder.',
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the cylinder is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the cylinder outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the cylinder outline.'
    )
    numberOfVerticalLines: Optional[Cylinder.Integer] = Field(
        16,
        description='The number of vertical lines to draw along the perimeter for the outline.',
    )
    slices: Optional[Cylinder.Integer] = Field(
        128, description='The number of edges around the perimeter of the cylinder.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the cylinder casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this cylinder will be displayed.',
    )


class Ellipse(BaseModel):
    """
    An ellipse, which is a closed curve on or above the surface of the Earth.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the ellipse is shown.'
    )
    semiMajorAxis: Optional[Cylinder.Double] = Field(
        None, description="The length of the ellipse's semi-major axis in meters."
    )
    semiMinorAxis: Optional[Cylinder.Double] = Field(
        None, description="The length of the ellipse's semi-minor axis in meters."
    )
    height: Optional[Cylinder.Double] = Field(
        '0.0', description='The altitude of the ellipse relative to the surface.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the ellipse, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Cylinder.Double] = Field(
        None,
        description="The altitude of the ellipse's extruded face relative to the surface.",
    )
    extrudedHeightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The extruded height reference of the ellipse, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    rotation: Optional[Cylinder.Double] = Field(
        '0.0', description='The angle from north (counter-clockwise) in radians.'
    )
    stRotation: Optional[Cylinder.Double] = Field(
        '0.0', description='The rotation of any applied texture coordinates.'
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the ellipse is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white', description='The material to use to fill the ellipse.'
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the ellipse is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the ellipse outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the ellipse outline.'
    )
    numberOfVerticalLines: Optional[Cylinder.Integer] = Field(
        '16',
        description='The number of vertical lines to use when outlining an extruded ellipse.',
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the ellipse casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this ellipse will be displayed.',
    )
    classificationType: Optional[Rectangle.ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Cylinder.Integer] = Field(
        '0',
        description='The z-index of the ellipse, used for ordering ground geometry. Only has an effect if the ellipse is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Ellipsoid(BaseModel):
    """
    A closed quadric surface that is a three-dimensional analogue of an ellipse.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the ellipsoid is shown.'
    )
    radii: Optional[Ellipsoid.EllipsoidRadii] = Field(
        None, description='The radii of the ellipsoid.'
    )
    innerRadii: Optional[Ellipsoid.EllipsoidRadii] = Field(
        None, description='The inner radii of the ellipsoid.'
    )
    minimumClock: Optional[Cylinder.Double] = Field(
        0.0, description='The minimum clock angle of the ellipsoid.'
    )
    maximumClock: Optional[Cylinder.Double] = Field(
        '2π', description='The maximum clock angle of the ellipsoid.'
    )
    minimumCone: Optional[Cylinder.Double] = Field(
        0.0, description='The minimum cone angle of the ellipsoid.'
    )
    maximumCone: Optional[Cylinder.Double] = Field(
        'π', description='The maximum cone angle of the ellipsoid.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the ellipsoid, which indicates if the position is relative to terrain or not.',
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the ellipsoid is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white',
        description='The material to display on the surface of the ellipsoid.',
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the ellipsoid is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the ellipsoid outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the ellipsoid outline.'
    )
    stackPartitions: Optional[Cylinder.Integer] = Field(
        64, description='The number of times to partition the ellipsoid into stacks.'
    )
    slicePartitions: Optional[Cylinder.Integer] = Field(
        64,
        description='The number of times to partition the ellipsoid into radial slices.',
    )
    subdivisions: Optional[Cylinder.Integer] = Field(
        128,
        description='The number of samples per outline ring, determining the granularity of the curvature.',
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED',
        description='Whether or not the ellipsoid casts or receives shadows.',
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this ellipsoid will be displayed.',
    )


class Polygon(BaseModel):
    """
    A polygon, which is a closed figure on the surface of the Earth.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the polygon is shown.'
    )
    positions: Optional[Polygon.PositionList] = Field(
        None, description='The array of positions defining a simple polygon.'
    )
    holes: Optional[Polygon.PositionListOfLists] = Field(
        None,
        description='The array of arrays of positions defining holes in the polygon.',
    )
    arcType: Optional[Polygon.ArcType] = Field(
        'GEODESIC',
        description='The type of arc that should connect the positions of the polygon.',
    )
    height: Optional[Cylinder.Double] = Field(
        0.0, description='The height of the polygon when `perPositionHeight` is false.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the polygon, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Cylinder.Double] = Field(
        None, description='The extruded height of the polygon.'
    )
    extrudedHeightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The extruded height reference of the polygon, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    stRotation: Optional[Cylinder.Double] = Field(
        0.0,
        description='The rotation of any applied texture. A positive rotation is counter-clockwise.',
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the polygon is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white', description='The material to use to fill the polygon.'
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the polygon is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the polygon outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the polygon outline.'
    )
    perPositionHeight: Optional[Cylinder.Boolean] = Field(
        False,
        description='Whether to use the height of each position to define the polygon or to use `height` as a constant height above the surface.',
    )
    closeTop: Optional[Cylinder.Boolean] = Field(
        True, description='Whether to close the top of the polygon.'
    )
    closeBottom: Optional[Cylinder.Boolean] = Field(
        True, description='Whether to close the bottom of the polygon.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the polygon casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this polygon will be displayed.',
    )
    classificationType: Optional[Rectangle.ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Cylinder.Integer] = Field(
        '0',
        description='The z-index of the polygon, used for ordering ground geometry. Only has an effect if the polygon is constant, and `height` and `extrudedHeight` are not specified.',
    )


class PolylineVolume(BaseModel):
    """
    A polyline with a volume, defined as a 2D shape extruded along a polyline that conforms to the curvature of the globe.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the volume is shown.'
    )
    positions: Optional[Polygon.PositionList] = Field(
        None,
        description='The array of positions defining the center of the polyline volume.',
    )
    shape: Optional[PolylineVolume.Shape] = Field(
        None,
        description='The array of positions defining the shape of the volume to be extruded.',
    )
    cornerType: Optional[Corridor.CornerType] = Field(
        'ROUNDED', description='The style of the corners of the volume.'
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the volume is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white', description='The material to use to fill the volume.'
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the volume is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the volume outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the volume outline.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the volume casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying the distance from the camera at which this volume will be displayed.',
    )


class Rectangle(BaseModel):
    """
    A cartographic rectangle, which conforms to the curvature of the globe and can be placed on the surface or at altitude and can optionally be extruded into a volume.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the rectangle is shown.'
    )
    coordinates: Optional[Rectangle.RectangleCoordinates] = Field(
        None, description='The coordinates of the rectangle.'
    )
    height: Optional[Cylinder.Double] = Field(
        0.0, description='The height of the rectangle.'
    )
    heightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The height reference of the rectangle, which indicates if `height` is relative to terrain or not.',
    )
    extrudedHeight: Optional[Cylinder.Double] = Field(
        None, description='The extruded height of the rectangle.'
    )
    extrudedHeightReference: Optional[Cylinder.HeightReference] = Field(
        'NONE',
        description='The extruded height reference of the rectangle, which indicates if `extrudedHeight` is relative to terrain or not.',
    )
    rotation: Optional[Cylinder.Double] = Field(
        0.0, description='The rotation of the rectangle clockwise from north.'
    )
    stRotation: Optional[Cylinder.Double] = Field(
        0.0,
        description='The rotation of any applied texture. A positive rotation is counter-clockwise.',
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the rectangle is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white',
        description='The material to display on the surface of the rectangle.',
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the rectangle is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the rectangle outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the rectangle outline.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED',
        description='Whether or not the rectangle casts or receives shadows.',
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this rectangle will be displayed.',
    )
    classificationType: Optional[Rectangle.ClassificationType] = Field(
        'BOTH',
        description='Whether a classification affects terrain, 3D Tiles, or both.',
    )
    zIndex: Optional[Cylinder.Integer] = Field(
        '0',
        description='The z-index of the rectangle, used for ordering ground geometry. Only has an effect if the rectangle is constant, and `height` and `extrudedHeight` are not specified.',
    )


class Wall(BaseModel):
    """
    A two-dimensional wall defined as a line strip and optional maximum and minimum heights, which conforms to the curvature of the globe and can be placed along the surface or at altitude.
    """

    show: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the wall is shown.'
    )
    positions: Optional[Polygon.PositionList] = Field(
        None, description='The array of positions defining the centerline of the wall.'
    )
    minimumHeights: Optional[DoubleList] = Field(
        None,
        description='The list of heights to be used for the bottom of the wall, instead of the surface.',
    )
    maximumHeights: Optional[DoubleList] = Field(
        None,
        description='The list of heights to be used for the top of the wall, instead of the height of each position.',
    )
    granularity: Optional[Cylinder.Double] = Field(
        'π / 180.0', description='The sampling distance, in radians.'
    )
    fill: Optional[Cylinder.Boolean] = Field(
        True, description='Whether or not the wall is filled.'
    )
    material: Optional[Cylinder.Material] = Field(
        'solid white', description='The material to display on the surface of the wall.'
    )
    outline: Optional[Cylinder.Boolean] = Field(
        False, description='Whether or not the wall is outlined.'
    )
    outlineColor: Optional[Cylinder.Color] = Field(
        'black', description='The color of the wall outline.'
    )
    outlineWidth: Optional[Cylinder.Double] = Field(
        1.0, description='The width of the wall outline.'
    )
    shadows: Optional[Cylinder.ShadowMode] = Field(
        'DISABLED', description='Whether or not the wall casts or receives shadows.'
    )
    distanceDisplayCondition: Optional[Cylinder.DistanceDisplayCondition] = Field(
        None,
        description='The display condition specifying at what distance from the camera this wall will be displayed.',
    )


class ConicSensor(BaseModel):
    """
    A conical sensor volume taking into account occlusion of an ellipsoid, i.e., the globe.
    """

    show: Optional[Boolean] = Field(
        True, description='Whether or not the entire conical sensor is shown.'
    )
    innerHalfAngle: Optional[Double] = Field(
        0.0, description='The inner half angle of the cone.'
    )
    outerHalfAngle: Optional[Double] = Field(
        'π', description='The outer half angle of the cone.'
    )
    minimumClockAngle: Optional[Double] = Field(
        0.0, description='The minimum clock angle limit of the cone.'
    )
    maximumClockAngle: Optional[Double] = Field(
        '2π', description='The maximum clock angle limit of the cone.'
    )
    radius: Optional[Double] = Field(
        'Infinity', description='The radial limit of the sensor.'
    )
    showIntersection: Optional[Boolean] = Field(
        True,
        description='Whether or not the intersection of the sensor with the Earth is shown.',
    )
    intersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection of the sensor with the Earth.',
    )
    intersectionWidth: Optional[Double] = Field(
        1.0, description='The width of the intersection in pixels.'
    )
    showLateralSurfaces: Optional[Boolean] = Field(
        True,
        description='Whether or not the lateral surfaces, i.e., the outer sides of the sensor, are shown.',
    )
    lateralSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's lateral surface, i.e., the outer sides of the sensor.",
    )
    showEllipsoidSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid surfaces are shown.'
    )
    ellipsoidSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid surfaces.",
    )
    showEllipsoidHorizonSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not ellipsoid horizon surfaces are shown.'
    )
    ellipsoidHorizonSurfaceMaterial: Optional[Material] = Field(
        'solid white',
        description="The material to use for the sensor's ellipsoid horizon surfaces.",
    )
    showDomeSurfaces: Optional[Boolean] = Field(
        True, description='Whether or not dome surfaces are shown.'
    )
    domeSurfaceMaterial: Optional[Material] = Field(
        'solid white', description="The material to use for the sensor's dome surfaces."
    )
    portionToDisplay: Optional[SensorVolumePortionToDisplay] = Field(
        'COMPLETE', description='What part of the sensor should be displayed.'
    )
    environmentConstraint: Optional[Boolean] = Field(
        False,
        description='Whether or not the sensor will be occluded by objects in the current view of the environment, e.g. visible terrain or models.',
    )
    showEnvironmentOcclusion: Optional[Boolean] = Field(
        False,
        description='Whether or not the portion of the terrain occluded by the environment will be drawn with a separate material.',
    )
    environmentOcclusionMaterial: Optional[Material] = Field(
        'solid white',
        description='The material to use for the portion of the sensor occluded by the environment.',
    )
    showEnvironmentIntersection: Optional[Boolean] = Field(
        False,
        description='Whether or not a line showing where the sensor intersects the environment will be drawn.',
    )
    environmentIntersectionColor: Optional[Color] = Field(
        'white',
        description='The color of the intersection line between the sensor and the environment.',
    )
    environmentIntersectionWidth: Optional[Double] = Field(
        5.0,
        description='The width in meters of the intersection line between the sensor and the environment.',
    )
    showThroughEllipsoid: Optional[Boolean] = Field(
        False,
        description='Whether or not a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out to the other side.',
    )
    showViewshed: Optional[Boolean] = Field(
        False, description='Whether or not the viewshed of the sensor will be drawn.'
    )
    viewshedVisibleColor: Optional[Color] = Field(
        'lime, 50% transparent',
        description='The color of the scene geometry that is visible to the sensor.',
    )
    viewshedOccludedColor: Optional[Color] = Field(
        'red, 50% transparent',
        description='The color of the scene geometry that is not visible to the sensor.',
    )
    viewshedResolution: Optional[Integer] = Field(
        2048, description='The resolution in pixels of the viewshed.'
    )


class Packet(BaseModel):
    """
    Describes the graphical properties of a single object in a scene, such as a single aircraft.
    """

    id: Optional[str] = Field(
        None,
        description='The ID of the object described by this packet. IDs do not need to be GUIDs, but they do need to uniquely identify a single object within a CZML source and any other CZML sources loaded into the same scope. If this property is not specified, the client will automatically generate a unique one. However, this prevents later packets from referring to this object in order to add more data to it.',
    )
    delete: Optional[bool] = Field(
        None,
        description='Whether the client should delete all existing data for this object, identified by ID. If true, all other properties in this packet will be ignored.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the object. It does not have to be unique and is intended for user consumption.',
    )
    parent: Optional[str] = Field(
        None, description='The ID of the parent object, if any.'
    )
    description: Optional[Label.String] = Field(
        None, description='An HTML description of the object.'
    )
    clock: Optional[Clock] = Field(
        None,
        description='The clock settings for the entire data set. Only valid on the document object.',
    )
    version: Optional[str] = Field(
        None,
        description='The CZML version being written. Only valid on the document object.',
    )
    availability: Optional[TimeIntervalCollectionValue] = Field(
        '0000-00-00T00:00:00Z/9999-12-31T24:00:00Z',
        description='The set of time intervals over which data for an object is available. The property can be a single string specifying a single interval, or an array of strings representing intervals. A later CZML packet can update this availability if it changes or is found to be incorrect. For example, an SGP4 propagator may initially report availability for all time, but then later the propagator throws an exception and the availability can be adjusted to end at that time. If this optional property is not present, the object is assumed to be available for all time. Availability is scoped to a particular CZML stream, so two different streams can list different availability for a single object. Within a single stream, the last availability stated for an object is the one in effect and any availabilities in previous packets are ignored. If an object is not available at a time, the client will not draw that object.',
    )
    properties: Optional[CustomProperties] = Field(
        None, description='A set of custom properties for this object.'
    )
    position: Optional[Position] = Field(
        None,
        description='The position of the object in the world. The position has no direct visual representation, but it is used to locate billboards, labels, and other graphical items attached to the object.',
    )
    orientation: Optional[Orientation] = Field(
        None,
        description='The orientation of the object in the world. The orientation has no direct visual representation, but it is used to orient models, cones, pyramids, and other graphical items attached to the object.',
    )
    viewFrom: Optional[ViewFrom] = Field(
        None,
        description="A suggested camera location when viewing this object. The property is specified as a Cartesian position in the East (x), North (y), Up (z) reference frame relative to the object's position.",
    )
    billboard: Optional[Billboard] = Field(
        None,
        description='A billboard, or viewport-aligned image, sometimes called a marker. The billboard is positioned in the scene by the `position` property.',
    )
    box: Optional[Box] = Field(
        None,
        description='A box, which is a closed rectangular cuboid. The box is positioned and oriented using the `position` and `orientation` properties.',
    )
    corridor: Optional[Corridor] = Field(
        None,
        description='A corridor, which is a shape defined by a centerline and width.',
    )
    cylinder: Optional[Cylinder] = Field(
        None,
        description='A cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius. The cylinder is positioned and oriented using the `position` and `orientation` properties.',
    )
    ellipse: Optional[Ellipse] = Field(
        None,
        description='An ellipse, which is a closed curve on the surface of the Earth. The ellipse is positioned using the `position` property.',
    )
    ellipsoid: Optional[Ellipsoid] = Field(
        None,
        description='An ellipsoid, which is a closed quadric surface that is a three-dimensional analogue of an ellipse. The ellipsoid is positioned and oriented using the `position` and `orientation` properties.',
    )
    label: Optional[Label] = Field(
        None,
        description='A string of text. The label is positioned in the scene by the `position` property.',
    )
    model: Optional[Model] = Field(
        None,
        description='A 3D model. The model is positioned and oriented using the `position` and `orientation` properties.',
    )
    path: Optional[Path] = Field(
        None,
        description='A path, which is a polyline defined by the motion of an object over time. The possible vertices of the path are specified by the `position` property.',
    )
    point: Optional[Point] = Field(
        None,
        description='A point, or viewport-aligned circle. The point is positioned in the scene by the `position` property.',
    )
    polygon: Optional[Polygon] = Field(
        None,
        description='A polygon, which is a closed figure on the surface of the Earth.',
    )
    polyline: Optional[Polyline] = Field(
        None,
        description='A polyline, which is a line in the scene composed of multiple segments.',
    )
    polylineVolume: Optional[PolylineVolume] = Field(
        None,
        description='A polyline with a volume, defined as a 2D shape extruded along a polyline.',
    )
    rectangle: Optional[Rectangle] = Field(
        None,
        description='A cartographic rectangle, which conforms to the curvature of the globe and can be placed along the surface or at altitude.',
    )
    tileset: Optional[Tileset] = Field(None, description='A 3D Tiles tileset.')
    wall: Optional[Wall] = Field(
        None,
        description='A two-dimensional wall which conforms to the curvature of the globe and can be placed along the surface or at altitude.',
    )
    agi_conicSensor: Optional[ConicSensor] = Field(
        None,
        description='A conical sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_customPatternSensor: Optional[CustomPatternSensor] = Field(
        None,
        description='A custom sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_rectangularSensor: Optional[RectangularSensor] = Field(
        None,
        description='A rectangular pyramid sensor volume taking into account occlusion of an ellipsoid, i.e., the globe. The sensor is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_fan: Optional[Fan] = Field(
        None,
        description='Defines a fan, which starts at a point or apex and extends in a specified list of directions from the apex. Each pair of directions forms a face of the fan extending to the specified radius. The fan is positioned and oriented using the `position` and `orientation` properties.',
    )
    agi_vector: Optional[Vector] = Field(
        None,
        description='Defines a graphical vector that originates at the `position` property and extends in the provided direction for the provided length. The vector is positioned using the `position` property.',
    )


class Document(BaseModel):
    """
    Describes a CZML document.
    """

    __root__: List[Packet] = Field(
        ..., description='Describes a CZML document.', title='Document'
    )
